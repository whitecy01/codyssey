# The OAuth 2.0 Authorization Framework
인터넷 표준을 제정 / 관리하는 국제 표준화 기구                                                                  편집자는 D.Hardt
RFC 문서 번호 6749                                                                                     소속기관: 마이크로소프트
이 문서는 RFC 5849를 폐기하고 대체함 즉, 6749가 최신 표준이고 5849는 더 이상 사용 권장되지 않음                        문서발표일 2012년 10월
인터넷 공식 표준으로 채택되는 과정에 있는 문서
RFC 시리즈 전체에 부여된 국제 표준 연속간행물번호

### 초록 (Abstract)
OAuth 2.0 권한 부여 프레임워크를 사용하면 타사 애플리케이션이 HTTP 서비스에 대한 제한된 액세스 권한을 얻을 수 있습니다. 이는 리소스 소유자와 HTTP 서비스 간의 승인 상호 작용을 조정하여 리소스 소유자를 대신해 액세스 권한을 얻거나, 타사 애플리케이션이 직접 액세스 권한을 얻도록 허용하는 방식으로 이루어질 수 있습니다. 이 사양은 RFC 5849에 설명된 OAuth 1.0 프로토콜을 대체하고 더 이상 사용하지 않도록 합니다.

### 이 문서의 상태(Status of This Memo)

이 문서는 인터넷 표준 트랙 문서입니다.

이 문서는 인터넷 엔지니어링 태스크 포스(IETF)의 산물이며, IETF 커뮤니티의 합의를 반영합니다. 공개 검토를 거쳐 인터넷 엔지니어링 운영 그룹(IESG)의 승인을 받아 발행되었습니다. 인터넷 표준에 대한 자세한 정보는 RFC 5741의 2절에서 확인할 수 있습니다.

이 문서의 현재 상태, 오류 수정 사항 및 의견 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc6749에서 확인할 수 있습니다.

### 저작권 고지(Copyright Notice)
저작권(c) 2012 IETF Trust 및 문서 작성자로 명시된 개인. 모든 권리 보유.

이 문서는 BCP 78 및 이 문서 발행일 현재 유효한 IETF 신탁의 IETF 문서 관련 법적 조항(http://trustee.ietf.org/license-info)의 적용을 받습니다. 이 문서와 관련하여 귀하의 권리와 제한 사항이 명시되어 있으므로 해당 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소에는 신탁 법적 조항 4.e항에 설명된 간소화된 BSD 라이선스 텍스트가 포함되어야 하며, 간소화된 BSD 라이선스에 명시된 바와 같이 어떠한 보증도 없이 제공됩니다.

## 목차
1. [소개](#1-소개)
    - 1.1. [역할](#11-역할)
    - 1.2. [프르토콜 흐름](#12-프로토콜-흐름)
    - 1.3. [권한 부여 방식](#13-인가-승인) 
      - 1.3.1. [인가 코드](#131-인가-코드)
      - 1.3.2. [암시적 권한 부여 방식](#132-암시적-권한-부여-방식) 
      - 1.3.3. [리소스 소유자 비밀번호 자격 증명 방식](#133-리소스-소유자-비밀번호-자격-증명)
      - 1.3.4. [클라이언트 자격 증명](#134-클라이언트-자격-증명)
    - 1.4. [Access Token](#14-access-token) 
    - 1.5. [Refresh Token](#15-refresh-token)
    - 1.6. [TLS 버전](#16-tls-버전)
    - 1.7. [HTTP 리디렉션](#17-http-리디렉션)
    - 1.8. [상호 운용성](#18-상호-운용성)
    - 1.9. [표기 규칙](#19-표기-규칙)
2. [클라이언트 등록](#2-클라이언트-등록)
    - 2.1. [클라이언트 유형](#21-클라이언트-유형)
    - 2.2. [클라이언트 식별자](#22-클라이언트-식별자)
    - 2.3. [클라이언트 인증](#23-클라이언트-인증)
      - 2.3.1. [클라이언트 비밀번호](#231-클라이언트-비밀번호)
      - 2.3.2. [기타 인증 방식](#232-기타-인증-방법)
    - 2.4. [미등록 클라이언트](#24-미등록-클라이언트)
3. [프로토콜 엔드포인트](#3-프로토콜-엔드포인트)
    - 3.1. [인가 엔드포인트](#31-인가-엔드포인트)
      - 3.1.1. [응답 유형](#311-응답-유형)
      - 3.1.2. [리다이렉션 엔드포인트](#312-리다이렉션-엔드포인트) 
        - 3.1.2.1. [엔드포인트 요청 기밀성 - 추가](#3121-엔드포인트-요청-기밀성)
        - 3.1.2.2. [등록 요구 사항 - 추가](#3122-등록-요구-사항)
        - 3.1.2.3. [동적 구성 - 추가](#3123-동적-구성)
        - 3.1.2.4. [유효하지 않은 엔드포인트 - 추가](#3124-유효하지-않은-엔드포인트)
        - 3.1.2.5. [엔드포인트 콘텐츠 - 추가](#3125-엔드포인트-콘텐츠)
    - 3.2. [토큰 엔드포인트](#32-토큰-엔드포인트)
      - 3.2.1. [클라이언트 인증](#321-클라이언트-인증)
    - 3.3. [액세스 토큰 범위](#33-액세스-토큰-범위)
4. 권한 획득 방법 
    - 4.1. 인가 코드 방식 
      - 4.1.1. 인가 요청 
      - 4.1.2. 인가 응답 
      - 4.1.3. 액세스 토큰 요청 
      - 4.1.4. 액세스 토큰 응답 
    - 4.2. Implicit 방식
      - 4.2.1. 인가 요청 
      - 4.2.2. 리소스 소유자 비밀번호 방식 
    - 4.3. 리소스 소유자 비밀번호 방식 
      - 4.3.1. 인가 요청 및 응답 
      - 4.3.2. 액세스 토큰 요청 
      - 4.3.3. 액세스 토큰 응답 
    - 4.4. 클라이언트 자격 증명 방식
      - 4.4.1. 인가 요청 및 응답
      - 4.4.2. 인가 요청 및 응답
      - 4.4.3. 액세스 토큰 응답
    - 4.5. 확장 그랜트
5. 액세스 토큰 발급 
    - 5.1. Successful Response
    - 5.2. Error Response 
6. 액세스 토큰 갱신 
7. 보호된 리소스 접근 
    - 7.1. 액세스 토큰 유형 
    - 7.2. Error Response
8. 확장성 
    - 8.1. 액세스 토큰 타입 정의 
    - 8.2. 새 엔드 포인트 파라미터 정의
    - 8.3. 새 권한 부여 방식 정의 
    - 8.4. 새 인가 엔드포인트 응답 타입 정의 
    - 8.5. 추가 오류 코드 정의 
9. 네이티브 애플리케이션 
10. 보안 고려 사항
    - 10.1. 클라이언트 인증 보안
    - 10.2. 클라이언트 사칭
    - 10.3. Access Tokens 
    - 10.4. Refresh Tokens
    - 10.5. Authorization Codes 
    - 10.6. 인가 코드 리다이렉트 URI 조작 
    - 10.7. 리소스 소유자 비밀번호 방식의 보안 문제 
    - 10.8. 요청 기밀성 
    - 10.9. 엔드포인트 진위 확인 
    - 10.10. 자격 증명 추측 공격
    - 10.11. 피싱 공격 
    - 10.12. 사이트 간 요청 위조 공격 
    - 10.13. 클릭재킹 공격 
    - 10.14. 코드 주입 및 입력값 검증 
    - 10.15. 오픈 리다이렉터 취약점 
    - 10.16. Implicit 방식에서 액세스 토큰을 악용해 사용자를 사칭하는 문제
11. IANA 관련 사항 
    - 11.1. OAuth 액세스 토큰 타입 등록소
      - 11.1.1. 등록 양식 
    - 11.2. Oauth 파라미터 등록소 
      - 11.2.1. 등록 양식 
      - 11.2.2. 초기 등록 목록 
    - 11.3. Oauth인가 엔드포인트 응답 타입 등록소
      - 11.3.1. 등록 양식
      - 11.3.2. 초기 등록 목록 
    - 11.4. Oauth 확장 오류 등록소
      - 11.4.1. 등록 양식
12. 참고 문헌
    - 12.1. 규범적 참고 문헌 
    - 12.2. 정보 제공용 참고 문헌
13. 부록 A. 확장된 BNF(ABNF) 문법
    - A.1.  "client_id" 문법 
    - A.2.  "client_secret" 문법 
    - A.3.  "response_type" 문법 
    - A.4.  "scope" 문법 
    - A.5.  "state" 문법
    - A.6.  "redirect_uri" 문법 
    - A.7.  "error" 문법
    - A.8.  "error_description" 문법
    - A.9.  "error_uri" 문법 
    - A.10. "grant_type" 문법 
    - A.11. "code" 문법 
    - A.12. "access_token" 문법 
    - A.13. "token_type" 문법 
    - A.14. "expires_in" 문법 
    - A.15. "username" 문법 
    - A.16. "password" 문법 
    - A.17. "refresh_token" 문법 
    - A.18. Endpoint Parameter 문법
14. 부록 B. application/x-www-form-urlencoded 미디어 타입 사용 
15. 부록 C. 감사의 글 

## 1. 소개
기존의 클라이언트-서버 인증 모델에서 클라이언트는 리소스 소유자의 자격 증명을 사용하여 서버에 인증함으로써 접근이 제한된 리소스(보호된 리소스)에 대한 접근을 요청합니다. 제3자 애플리케이션이 제한된 리소스에 접근할 수 있도록 하려면 리소스 소유자는 자신의 자격 증명을 제3자와 공유해야 합니다. 하지만 이로 인해 다음과 같은 몇 가지 문제점과 한계가 발생합니다.

- 타사 애플리케이션은 리소스 소유자의 자격 증명(일반적으로 평문으로 저장된 암호)을 향후 사용을 위해 저장해야 합니다.
- 서버는 암호에 내재된 보안 취약점에도 불구하고 암호 인증을 지원해야 합니다.
- 타사 애플리케이션은 리소스 소유자의 보호된 리소스에 대해 지나치게 광범위한 접근 권한을 획득하여, 리소스 소유자가 접근 기간이나 접근 범위를 리소스의 일부로 제한할 수 없게 됩니다.
- 리소스 소유자는 개별 타사의 접근 권한을 취소할 수 없으며, 모든 타사의 접근 권한을 취소하지 않고는 해당 타사의 접근 권한을 취소할 수 없습니다. 따라서 타사의 암호를 변경해야 합니다.
- 타사 애플리케이션이 손상되면 최종 사용자의 암호와 해당 암호로 보호되는 모든 데이터가 손상됩니다.

OAuth는 권한 부여 계층을 도입하고 클라이언트와 리소스 소유자의 역할을 분리함으로써 이러한 문제를 해결합니다. OAuth에서 클라이언트는 리소스 소유자가 관리하고 리소스 서버에서 호스팅하는 리소스에 대한 접근을 요청하고, 리소스 소유자와는 다른 자격 증명 세트를 발급받습니다.

클라이언트는 보호된 리소스에 접근할 때 리소스 소유자의 자격 증명을 사용하는 대신, 특정 범위, 유효 기간 및 기타 접근 속성을 나타내는 문자열인 액세스 토큰을 획득합니다. 액세스 토큰은 리소스 소유자의 승인을 받아 권한 부여 서버에서 제3자 클라이언트에게 발급됩니다. 클라이언트는 이 액세스 토큰을 사용하여 리소스 서버에서 호스팅하는 보호된 리소스에 접근합니다.

예를 들어, 최종 사용자(리소스 소유자)는 사진 공유 서비스(리소스 서버)에 저장된 보호된 사진에 대한 접근 권한을 인쇄 서비스(클라이언트)에 부여할 수 있습니다. 이때 사용자 이름과 비밀번호를 인쇄 서비스와 공유할 필요는 없습니다. 대신, 사진 공유 서비스에서 신뢰하는 서버(권한 부여 서버)에 직접 인증하여 인쇄 서비스에 대한 위임 전용 자격 증명(액세스 토큰)을 발급받습니다.

이 사양은 HTTP([RFC2616])와 함께 사용하도록 설계되었습니다.
HTTP 이외의 프로토콜을 통한 OAuth 사용은 이 사양의 범위를 벗어납니다.

정보 문서로 발표된 OAuth 1.0 프로토콜([RFC5849])은 소규모 임시 커뮤니티의 노력으로 탄생했습니다. 이 표준 트랙 사양은 OAuth 1.0 배포 경험과 더 넓은 IETF 커뮤니티에서 수집한 추가 사용 사례 및 확장성 요구 사항을 기반으로 합니다. OAuth 2.0 프로토콜은 OAuth 1.0과 하위 호환되지 않습니다. 두 버전은 네트워크에서 공존할 수 있으며, 구현체는 둘 다 지원하도록 선택할 수 있습니다. 그러나 이 사양의 의도는 새로운 구현체가 이 문서에 명시된 대로 OAuth 2.0을 지원하고 OAuth 1.0은 기존 배포를 지원하는 데에만 사용하도록 하는 것입니다. OAuth 2.0 프로토콜은 OAuth 1.0 프로토콜과 구현 세부 사항을 거의 공유하지 않습니다. OAuth 1.0에 익숙한 구현체는 이 문서의 구조와 세부 사항에 대한 어떠한 가정도 없이 접근해야 합니다.

### 1.1 역할
OAuth는 다음과 같은 네 가지 역할을 정의합니다.

1. 리소스 소유자
- 보호된 리소스에 대한 접근 권한을 부여할 수 있는 주체. 리소스 소유자가 사람인 경우, 최종 사용자라고 합니다.

2. 리소스 서버
- 보호된 리소스를 호스팅하고, 액세스 토큰을 사용하여 보호된 리소스 요청을 수락하고 응답할 수 있는 서버.

3. 클라이언트 
- 리소스 소유자를 대신하여 권한을 부여받아 보호된 리소스에 대한 요청을 하는 애플리케이션.
"클라이언트"라는 용어는 특정 구현 특성(예: 서버, 데스크톱 또는 기타 장치에서 실행되는지 여부)을 의미하지 않습니다.

4. 권한 부여 서버
- 리소스 소유자를 성공적으로 인증하고 권한을 획득한 후 클라이언트에게 액세스 토큰을 발급하는 서버.

권한 부여 서버와 리소스 서버 간의 상호 작용은 이 사양의 범위를 벗어납니다. 권한 부여 서버는 리소스 서버와 동일한 서버일 수도 있고, 별도의 개체일 수도 있습니다. 단일 권한 부여 서버는 여러 리소스 서버에서 허용되는 액세스 토큰을 발급할 수 있습니다.

### 1.2 프로토콜 흐름

```
     +--------+                                  +---------------+
     |        |---------(A)- 인가 요청------------>|   리소스 소유자  |
     |        |                                  |               |
     |        |<-(B)-- 인가 승인 정보(권한 부여 결과)---|               |
     |        |                                  +---------------+
     |        |
     |        |                                  +--------------+
     |        |--(C)-- 인가 승인 정보(권한 부여 결과)-->|    인가 서버    |
     | 클라이언트|                                  |               |
     |        |<-(D)----- Access Token ----------|               |
     |        |                                  +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    리소스 서버   |
     |        |                               |               |
     |        |<-(F)-------보호된 리소스---------|               |
     +--------+                               +---------------+

                     그림 1: 추상적인 프로토콜 흐름
```
그림 1에 나타낸 추상적인 OAuth 2.0 흐름은 네 가지 역할 간의 상호 작용을 설명하며 다음과 같은 단계를 포함합니다.

(A) 클라이언트는 리소스 소유자에게 권한 부여를 요청합니다. 권한 부여 요청은 리소스 소유자에게 직접 (그림과 같이) 또는 (가급적이면) 권한 부여 서버를 통해 간접적으로 수행할 수 있습니다.
(B) 클라이언트는 권한 부여 부여(authorization grant)를 수신합니다. 이는 리소스 소유자의 권한을 나타내는 자격 증명으로, 이 명세에 정의된 네 가지 부여 유형 중 하나 또는 확장 부여 유형을 사용하여 표현됩니다. 권한 부여 부여 유형은 클라이언트가 권한을 요청하는 데 사용한 방법과 권한 부여 서버에서 지원하는 유형에 따라 달라집니다.
(C) 클라이언트는 권한 부여 서버에 인증하고 권한 부여 부여를 제시하여 액세스 토큰을 요청합니다.
(D) 권한 부여 서버는 클라이언트를 인증하고 권한 부여를 검증하며, 유효한 경우 액세스 토큰을 발급합니다.
(E) 클라이언트는 리소스 서버에 보호된 리소스를 요청하고 액세스 토큰을 제시하여 인증합니다.
(F) 리소스 서버는 액세스 토큰을 검증하고, 유효한 경우 요청을 처리합니다.

클라이언트가 리소스 소유자로부터 권한 부여를 얻는 데 선호되는 방법(단계 (A) 및 (B)에 설명됨)은 권한 부여 서버를 중개자로 사용하는 것이며 이는 섹션 4.1의 그림 3에 설명되어 있습니다.

### 1.3 권한 부여 방식
권한 부여는 클라이언트가 액세스 토큰을 얻기 위해 사용하는 리소스 소유자의 권한(보호된 리소스에 접근할 수 있는 권한)을 나타내는 자격 증명입니다. 이 사양에서는 권한 부여 코드, 암시적, 리소스 소유자 암호 자격 증명 및 클라이언트 자격 증명의 네 가지 부여 유형과 추가 유형을 정의할 수 있는 확장 메커니즘을 정의합니다.

#### 1.3.1 인가 코드
Authorization Code 방식에서는, 클라이언트와 사용자 사이에서 인가 서버가 중간 역할을 한다. 클라이언트는 사용자에게 직접 “권한을 주세요”라고 요청하지 않고, 사용자를 인가 서버로 보내어(브라우저 같은 사용자 에이전트를 통해) 인가 서버가 대신 처리하도록 한다. 인가 서버는 사용자를 인증(로그인)하고 클라이언트가 요청한 권한에 대해 사용자의 동의를 받은 뒤 사용자를 다시 클라이언트로 돌려보내면서 ‘인가 코드(authorization code)’를 전달한다. 이 과정에서 사용자는 오직 인가 서버에만 로그인하기 때문에, 사용자의 아이디와 비밀번호는 클라이언트에 절대 전달되지 않는다.

인증 코드는 클라이언트를 인증하는 기능과 리소스 소유자의 사용자 에이전트를 거치지 않고 액세스 토큰을 클라이언트에 직접 전송하여 리소스 소유자를 포함한 다른 사람에게 노출될 가능성을 줄이는 기능 등 몇 가지 중요한 보안 이점을 제공합니다.

#### 1.3.2 암시적 권한 부여 방식
Implicit Grant(암시적 권한 부여 방식)은 JavaScript와 같은 스크립트 언어를 사용해 브라우저에서 구현된 클라이언트에 최적화된 간소화된 Authorization Code 흐름입니다. Implicit 흐름에서는 클라이언트에게 인가 코드(authorization code)를 발급하는 대신 리소스 소유자의 승인 결과로 액세스 토큰을 직접 발급합니다. 이 방식은 인가 코드와 같은 중간 자격 증명이 발급되지 않고 (그리고 이후에 액세스 토큰을 얻는 데 사용되지도 않기 때문에) grant 타입이 ‘implicit(암시적)’이라고 불린다.


Implicit Grant 흐름에서 액세스 토큰을 발급할 때 인가 서버는 클라이언트를 인증하지 않습니다. 일부 경우에는 액세스 토큰을 클라이언트에 전달하기 위해 사용되는 리다이렉션 URI를 통해 클라이언트의 식별을 확인할 수도 있다. 하지만 액세스 토큰은 리소스 소유자 또는 리소스 소유자의 사용자 에이전트에 접근할 수 있는 다른 애플리케이션에 노출될 수 있다.

Implicit Grant는 액세스 토큰을 얻기 위해 필요한 통신 왕복 횟수를 줄이기 때문에 브라우저 내에서 동작하는 애플리케이션과 같은 일부 클라이언트에서는 응답성과 효율성을 향상시킨다. 그러나 이러한 편의성은 특히 Authorization Code Grant를 사용할 수 있는 경우에는 섹션 10.3과 10.16에서 설명된 것과 같은 Implicit Grant 사용에 따른 보안상의 영향을 충분히 고려한 후에 선택되어야 한다.

#### 1.3.3 리소스 소유자 비밀번호 자격 증명
리소스 소유자의 비밀번호 자격 증명(즉, 사용자 이름과 비밀번호)은 액세스 토큰을 얻기 위한 인가 승인 정보(authorization grant)로서 직접 사용될 수 있다. 이 자격 증명은 리소스 소유자와 클라이언트 사이에 높은 수준의 신뢰가 존재하는 경우에만 사용되어야 하며 (예: 클라이언트가 디바이스 운영체제의 일부이거나, 매우 높은 권한을 가진 애플리케이션인 경우), 그리고 인가 코드와 같은 다른 인가 승인 방식이 사용할 수 없는 경우에만 사용되어야 한다.

이 인가 승인 방식은 클라이언트가 리소스 소유자의 자격 증명에 직접 접근해야 함에도 불구하고 리소스 소유자의 자격 증명은 단 한 번의 요청에만 사용되며 그 이후에는 액세스 토큰으로 교환된다. 이 방식은 자격 증명을 장기적으로 사용 가능한 액세스 토큰이나 리프레시 토큰으로 교환함으로써 클라이언트가 리소스 소유자의 자격 증명을 향후 사용을 위해 저장할 필요를 없앨 수 있다.

#### 1.3.4 클라이언트 자격 증명
클라이언트 자격 증명(또는 다른 형태의 클라이언트 인증 수단)은 인가 범위가 클라이언트의 관리 하에 있는 보호된 리소스로 제한되거나 또는 사전에 인가 서버와 협의된 보호된 리소스에 한정되는 경우 인가 승인 정보(authorization grant)로 사용될 수 있다. 클라이언트 자격 증명은 일반적으로 클라이언트가 자기 자신을 대표하여 동작하는 경우(즉, 클라이언트가 리소스 소유자이기도 한 경우) 또는 인가 서버와 미리 합의된 인가를 기반으로 보호된 리소스에 접근을 요청하는 경우에 인가 승인 정보로 사용된다.

### 1.4 Access Token
액세스 토큰(access token)은 보호된 리소스에 접근하기 위해 사용되는 자격 증명이다. 액세스 토큰은 클라이언트에게 발급된 인가(authorization)를 나타내는 문자열이다. 이 문자열은 보통 클라이언트가 해석할 수 없는 불투명한 값이다. 토큰은 리소스 소유자가 부여한 특정 접근 범위(scope)와 접근 기간(duration)을 나타내며,
이 접근 권한은 리소스 서버와 인가 서버에 의해 강제된다.

이 토큰은 인가 정보를 조회하기 위해 사용되는 식별자(identifier)를 나타낼 수도 있고, 또는 인가 정보를 자체적으로 포함하고 검증 가능한 형태일 수도 있다(즉, 데이터와 서명으로 구성된 토큰 문자열일 수 있다). 이 명세의 범위를 벗어나는 추가적인 인증 자격 증명이 클라이언트가 토큰을 사용하기 위해 요구될 수도 있다.

액세스 토큰은 사용자 이름과 비밀번호와 같은 다양한 인가 수단을 하나의 토큰으로 대체하는 추상화 계층을 제공하며, 이 토큰은 리소스 서버가 이해할 수 있는 단일한 형태로 사용된다. 이러한 추상화는 토큰을 발급받는 데 사용된 인가 승인 정보보다 더 제한적인 권한을 가진 액세스 토큰을 발급할 수 있게 해주며 리소스 서버가 다양한 인증 방식들을 모두 이해할 필요를 없애준다.

액세스 토큰은 리소스 서버의 보안 요구 사항에 따라 서로 다른 형식, 구조, 그리고 사용 방식 (예: 암호학적 속성)을 가질 수 있다. 액세스 토큰의 속성과 보호된 리소스에 접근하는 방법에 대한 상세 내용은 이 명세의 범위를 벗어나며 [RFC6750]과 같은 관련 명세에서 정의된다.

### 1.5 Refresh Token
리프레시 토큰은 액세스 토큰을 얻기 위해 사용되는 자격 증명이다. 리프레시 토큰은 인가 서버가 클라이언트에게 발급하며 현재의 액세스 토큰이 유효하지 않게 되거나 만료되었을 때 또는 동일하거나 더 제한된 범위(scope)를 가진 추가 액세스 토큰을 얻기 위해 사용된다 (액세스 토큰은 리소스 소유자가 허락한 권한보다 더 짧은 수명이나 더 적은 권한을 가질 수 있다). 리프레시 토큰을 발급할지는 인가 서버의 재량에 따라 선택 사항이다. 인가 서버가 리프레시 토큰을 발급하는 경우, 이는 액세스 토큰을 발급할 때 함께 포함된다(즉, 그림 1의 단계 (D)).

리프레시 토큰은 리소스 소유자가 클라이언트에게 부여한 인가를 나타내는 문자열이다. 이 문자열은 보통 클라이언트가 해석할 수 없는 불투명한 값이다. 이 토큰은 인가 정보를 조회하기 위해 사용되는 식별자(identifier)를 나타낸다. 액세스 토큰과 달리 리프레시 토큰은 인가 서버에서만 사용하도록 의도된 것이며 리소스 서버에는 절대 전달되지 않는다.


```
  +--------+                                           +---------------+
  |        |--(A)------- 인가 승인 정보 ----------------->|               |
  |        |                                           |               |
  |        |<-(B)----------- Access Token -------------|               |
  |        |               & Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token ----------->|               |
  |        |                                           |               |
  |        |<-(H)----------- Access Token -------------|               |
  +--------+           & Optional Refresh Token        +---------------+

               Figure 2:  만료된 액세스 토큰 갱신 흐름
```

그림 2에 나타난 흐름은 다음 단계를 포함한다.

(A) 클라이언트는 인가 서버에 인증하고 인가 승인 정보(authorization grant)를 제시하여 액세스 토큰을 요청한다.

(B) 인가 서버는 클라이언트를 인증하고 인가 승인 정보를 검증하며 유효한 경우 액세스 토큰과 리프레시 토큰을 발급한다.

(C) 클라이언트는 액세스 토큰을 제시하여 리소스 서버에 보호된 리소스를 요청한다.

(D) 리소스 서버는 액세스 토큰을 검증하고 유효한 경우 요청을 처리한다.

(E) 액세스 토큰이 만료될 때까지 (C)와 (D) 단계가 반복된다. 클라이언트가 액세스 토큰의 만료를 알고 있다면 (G) 단계로 바로 이동하고 그렇지 않으면 다시 보호된 리소스를 요청한다.

(F) 액세스 토큰이 유효하지 않으므로 리소스 서버는 유효하지 않은 토큰 오류를 반환한다.

(G) 클라이언트는 인가 서버에 인증하고 리프레시 토큰을 제시하여 새로운 액세스 토큰을 요청한다. 클라이언트 인증 요구 사항은 클라이언트 유형과 인가 서버 정책에 따라 달라진다.

(H) 인가 서버는 클라이언트를 인증하고 리프레시 토큰을 검증하며 유효한 경우 새로운 액세스 토큰을 발급하고 (선택적으로) 새로운 리프레시 토큰도 함께 발급한다.

단계 (C), (D), (E), (F)는 7절에서 설명된 바와 같이 이 명세의 범위를 벗어난다.

### 1.6 TLS 버전
이 명세에서 전송 계층 보안(Transport Layer Security, TLS)이 사용되는 경우, 적절한 TLS 버전(또는 버전들)은 시간이 지나면서 달라질 수 있으며, 이는 널리 배포된 정도와 알려진 보안 취약점에 따라 결정된다. 이 문서가 작성된 시점에서는, TLS 버전 1.2 [RFC5246]가 가장 최신 버전이지만, 배포된 범위가 매우 제한적이며 구현 환경에서 즉시 사용하기 어려울 수도 있다. TLS 버전 1.0 [RFC2246]은 가장 널리 배포된 버전이며, 가장 폭넓은 상호 운용성을 제공한다.

구현체는 또한, 자신들의 보안 요구 사항을 충족하는 경우에 한해 추가적인 전송 계층 보안 메커니즘을 지원할 수도 있다.

### 1.7 HTTP 리디렉션
이 명세는 HTTP 리다이렉션을 광범위하게 사용하며 이 과정에서 클라이언트 또는 인가 서버가 리소스 소유자의 사용자 에이전트(user-agent)를 다른 목적지로 이동시키도록 지시한다. 이 명세에 포함된 예제들은 HTTP 302 상태 코드를 사용하는 경우를 보여주지만, 사용자 에이전트를 통해 이러한 리다이렉션을 수행할 수 있는 다른 모든 방법 또한 허용되며 이는 구현 세부 사항(implementation detail)으로 간주된다.

### 1.8 상호 운용성
OAuth 2.0은 명확하게 정의된 보안 특성을 갖춘 풍부한 인가 프레임워크를 제공한다. 그러나 이 프레임워크는 구성 요소가 많고 선택 사항이 많은 매우 확장 가능한 구조이기 때문에 이 명세만으로는 서로 호환되지 않는 다양한 구현체들이 생길 가능성이 크다.

또한 이 명세는 몇 가지 필수 구성 요소들을 부분적으로만 정의하거나 아예 정의하지 않고 남겨두고 있다(예: 클라이언트 등록, 인가 서버의 기능, 엔드포인트 탐색 등). 이러한 구성 요소들이 없으면 클라이언트는 특정 인가 서버 및 리소스 서버와 상호 운용하기 위해 수동으로 개별 설정을 해야만 한다.

이 프레임워크는 처음부터 향후 작업을 통해 웹 전체 규모에서의 완전한 상호 운용성을 달성하기 위해 필요한 규범적인 프로파일과 확장들이 정의될 것이라는 명확한 기대를 가지고 설계되었다.

### 1.9 표기 규칙
이 명세에서 사용되는 “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, “OPTIONAL”과 같은 핵심 단어들은 [RFC2119]에 설명된 의미로 해석되어야 한다.

이 명세는 [RFC5234]에 정의된 확장 백우스-나우르 형식(Augmented Backus-Naur Form, ABNF)표기법을 사용한다. 또한, “Uniform Resource Identifier (URI): Generic Syntax” [RFC3986]에 정의된 URI-reference 규칙을 포함한다.

일부 보안 관련 용어들은 [RFC4949]에 정의된 의미로 이해되어야 한다. 이러한 용어에는 “attack(공격)”, “authentication(인증)”, “authorization(인가)”, “certificate(인증서)”, “confidentiality(기밀성)”, “credential(자격 증명)”, “encryption(암호화)”, “identity(신원)”, “sign(서명하다)”, “signature(서명)”, “trust(신뢰)”, “validate(유효성 검사)”, “verify(검증)” 등이 포함되며, 이에 한정되지는 않는다.

별도로 명시되지 않는 한, 모든 프로토콜 파라미터 이름과 값은 대소문자를 구분한다.

## 2. 클라이언트 등록
프로토콜을 시작하기 전에, 클라이언트는 인가 서버에 등록(register)해야 한다. 클라이언트가 인가 서버에 등록하는 방법은 이 명세의 범위를 벗어나지만, 일반적으로는 HTML 등록 양식을 통한 최종 사용자와의 상호작용을 포함한다.

클라이언트 등록은 반드시 클라이언트와 인가 서버 간의 직접적인 상호작용을 요구하지는 않는다. 인가 서버가 이를 지원하는 경우, 등록은 신뢰를 설정하고 필요한 클라이언트 속성들을 얻기 위한 다른 방법들에 의존할 수 있다(예: 리다이렉션 URI, 클라이언트 유형). 예를 들어, 등록은 자체 발급된(assertion) 또는 제3자가 발급한 assertion을 사용하여 이루어질 수도 있고, 또는 인가 서버가 신뢰된 채널을 통해 클라이언트를 탐색(discovery)함으로써 수행될 수도 있다.

클라이언트를 등록할 때,클라이언트 개발자는 반드시 다음을 수행해야 한다(SHALL):
- 섹션 2.1에 설명된 대로 클라이언트 유형(client type)을 지정해야 한다.
- 섹션 3.1.2에 설명된 대로 클라이언트 리다이렉션 URI를 제공해야 한다.
- 그리고 인가 서버가 요구하는 기타 모든 정보를 포함해야 한다(예: 애플리케이션 이름, 웹사이트, 설명, 로고 이미지, 법적 약관에 대한 동의).

### 2.1 클라이언트 유형
OAuth는 인가 서버와 안전하게 인증할 수 있는 능력, 즉 클라이언트 자격 증명의 기밀성을 유지할 수 있는 능력을 기준으로 두 가지 클라이언트 유형을 정의한다.

- 기밀 클라이언트(confidential)
기밀 클라이언트는 자신의 자격 증명의 기밀성을 유지할 수 있는 클라이언트이다(예: 클라이언트 자격 증명에 대한 접근이 제한된 보안 서버에서 구현된 클라이언트), 또는 다른 수단을 사용하여 안전한 클라이언트 인증이 가능한 경우를 말한다.

- 공개 클라이언트(public)
공개 클라이언트는 자신의 자격 증명의 기밀성을 유지할 수 없는 클라이언트이다(예: 리소스 소유자가 사용하는 장치에서 실행되는 클라이언트로, 설치형 네이티브 애플리케이션이나 웹 브라우저 기반 애플리케이션 등), 그리고 어떠한 다른 방법으로도 안전한 클라이언트 인증이 불가능한 경우를 말한다.

클라이언트 유형의 지정은 인가 서버가 정의한 안전한 인증 기준과 클라이언트 자격 증명이 노출될 수 있는 허용 수준을 기준으로 한다. 인가 서버는 클라이언트 유형에 대해 임의로 가정해서는 안 된다(SHOULD NOT).


클라이언트는 각각 다른 클라이언트 유형과 보안 환경을 가진 여러 구성 요소로 분산되어 구현될 수도 있다 (예: 기밀 서버 기반 구성 요소와 공개 브라우저 기반 구성 요소를 모두 가진 분산 클라이언트).

인가 서버가 이러한 클라이언트를 지원하지 않거나 등록에 대한 지침을 제공하지 않는 경우, 클라이언트는 각 구성 요소를 별도의 클라이언트로 등록해야 한다(SHOULD).

이 명세는 다음과 같은 클라이언트 프로파일을 기준으로 설계되었다.
- 웹 애플리케이션(web application)
웹 애플리케이션은 웹 서버에서 실행되는 기밀 클라이언트이다. 리소스 소유자는 자신의 장치에 있는 사용자 에이전트에서 렌더링된 HTML 사용자 인터페이스를 통해 이 클라이언트에 접근한다. 클라이언트 자격 증명과 클라이언트에게 발급된 모든 액세스 토큰은 웹 서버에 저장되며, 리소스 소유자에게 노출되거나 접근 가능하지 않다.

- 사용자 에이전트 기반 애플리케이션(user-agent-based application)
사용자 에이전트 기반 애플리케이션은 웹 서버로부터 클라이언트 코드가 다운로드되어 리소스 소유자가 사용하는 장치의 사용자 에이전트(예: 웹 브라우저) 내에서 실행되는 공개 클라이언트이다. 프로토콜 데이터와 자격 증명은 리소스 소유자가 쉽게 접근할 수 있으며 (종종 눈에 보이기도 한다). 이러한 애플리케이션은 사용자 에이전트 내부에 존재하기 때문에, 인가를 요청할 때 사용자 에이전트의 기능을 자연스럽게 활용할 수 있다.

- native application (네이티브 애플리케이션)
네이티브 애플리케이션은 리소스 소유자가 사용하는 장치에 설치되어 실행되는 공개 클라이언트이다. 프로토콜 데이터와 자격 증명은 리소스 소유자가 접근할 수 있다. 애플리케이션에 포함된 어떠한 클라이언트 인증 자격 증명도 추출될 수 있다고 가정한다. 반면, 액세스 토큰이나 리프레시 토큰과 같이 동적으로 발급되는 자격 증명은 허용 가능한 수준의 보호를 받을 수 있다. 최소한, 이러한 자격 증명은 애플리케이션이 상호작용할 수 있는 악의적인 서버로부터는 보호된다. 일부 플랫폼에서는 같은 장치에 존재하는 다른 애플리케이션으로부터도 이 자격 증명이 보호될 수 있다.

### 2.2 클라이언트 식별자
인가 서버는 등록된 클라이언트에게 클라이언트 식별자(client identifier)를 발급한다. 이 클라이언트 식별자는 클라이언트가 제공한 등록 정보를 나타내는 고유한 문자열이다. 클라이언트 식별자는 비밀 값이 아니며, 리소스 소유자에게 노출된다. 따라서 클라이언트 식별자는 클라이언트 인증을 위해 단독으로 사용되어서는 안 된다(MUST NOT). 클라이언트 식별자는 해당 인가 서버에 대해서만 고유하다.

클라이언트 식별자 문자열의 크기(길이)는 이 명세에서 정의하지 않는다. 클라이언트는 식별자의 크기에 대해 임의로 가정해서는 안 된다. 인가 서버는 자신이 발급하는 모든 식별자의 크기를 문서로 명시하는 것이 바람직하다(SHOULD).

### 2.3 클라이언트 인증
클라이언트 유형이 기밀 클라이언트(confidential)인 경우, 클라이언트와 인가 서버는 인가 서버의 보안 요구 사항에 적합한 클라이언트 인증 방법을 설정한다. 인가 서버는 자신의 보안 요구 사항을 충족하는 어떠한 형태의 클라이언트 인증 방식도 받아들일 수 있다(MAY).

기밀 클라이언트는 일반적으로 인가 서버와 인증하기 위해 사용되는 클라이언트 자격 증명 집합을 발급받거나(또는 설정한다) (예: 비밀번호, 공개키/개인키 쌍).

인가 서버는 공개 클라이언트(public client)와도 클라이언트 인증 방법을 설정할 수 있다(MAY). 그러나 인가 서버는 클라이언트를 식별하기 위한 목적으로 공개 클라이언트의 인증에 의존해서는 안 된다(MUST NOT).

클라이언트는 각 요청마다 하나를 초과하는 인증 방법을 사용해서는 안 된다(MUST NOT).

### 2.3.1 클라이언트 비밀번호
클라이언트 비밀번호를 보유한 클라이언트는, [RFC2617]에 정의된 HTTP Basic 인증 방식을 사용하여 인가 서버에 인증할 수 있다(MAY). 이때 클라이언트 식별자는 부록 B에 따라 “application/x-www-form-urlencoded” 인코딩 알고리즘으로 인코딩되어 사용자 이름(username)으로 사용되며, 클라이언트 비밀번호는 같은 인코딩 알고리즘으로 인코딩되어 비밀번호(password)로 사용된다. 인가 서버는 클라이언트 비밀번호가 발급된 클라이언트를 인증하기 위해 HTTP Basic 인증 방식을 반드시 지원해야 한다(MUST).

예시 (표시를 위해 줄바꿈을 추가한 것임)
```
Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3
```
대안적으로, 인가 서버는 다음 파라미터를 사용하여 요청 본문(request-body)에 클라이언트 자격 증명을 포함하는 방식을 지원할 수도 있다(MAY).

- client_id
  - 필수(REQUIRED), 섹션 2.2에서 설명된 등록 과정 중 클라이언트에게 발급된 클라이언트 식별자
- client_secret
  - 필수(REQUIRED), 클라이언트 비밀 값, 클라이언트 비밀 값이 빈 문자열인 경우, 클라이언트는 이 파라미터를 생략할 수 있다(MAY)

이 두 파라미터를 사용하여 요청 본문에 클라이언트 자격 증명을 포함하는 방식은 권장되지 않는다(NOT RECOMMENDED). 이 방식은 HTTP Basic 인증 방식(또는 다른 비밀번호 기반 HTTP 인증 방식)을 직접 사용할 수 없는 클라이언트로 제한되어야 한다(SHOULD). 이 파라미터들은 요청 본문에서만 전송될 수 있으며, 요청 URI에는 포함되어서는 안 된다(MUST NOT).

예시: 액세스 토큰을 새로고침하기 위해 (Section 6) 아래와 같은 바디 파라미터를 사용하는 요청
```
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
&client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
```

1.6절에 명시한 것처럼, 인가 서버는 비밀번호 인증을 사용하는 요청에 대해 TLS 사용을 요구해야한다 (MUST).

해당 인증 방식은 비밀번호를 포함하기 때문에 인가 서버는 이러한 방식을 사용하는 엔드포인트를 무차별 공격 (bruteforce attack) 으로부터 보호해야한다(MUST).

### 2.3.2 기타 인증 방법
인가 서버는 자신의 보안 요구 사항에 부합하는 어떠한 적절한 HTTP 인증 방식도 지원할 수 있다(MAY). 다른 인증 방식을 사용하는 경우, 인가 서버는 클라이언트 식별자(등록 기록)와 인증 방식 사이의 매핑 관계를 반드시 정의해야 한다(MUST).

### 2.4 미등록 클라이언트
이 명세는 등록되지 않은 클라이언트의 사용을 배제하지는 않는다. 그러나 이러한 클라이언트의 사용은 이 명세의 범위를 벗어나며, 그 사용에 대해서는 추가적인 보안 분석과 상호 운용성에 미치는 영향에 대한 검토가 필요하다.

## 3. 프로토콜 엔드포인트
인가 과정은 두 개의 인가 서버 엔드포인트(HTTP 리소스)를 사용한다.

- Authorization endpoint(인가 엔드포인트) 클라이언트가 사용자 에이전트 리다이렉션을 통해 리소스 소유자로부터 인가를 얻기 위해 사용하는 엔드포인트
- Token endpoint(토큰 엔드포인트) 클라이언트가 인가 승인 정보(authorization grant)를 액세스 토큰으로 교환하기 위해 사용하는 엔드포인트이며 일반적으로 클라이언트 인증을 포함한다.

또한, 다음과 같은 하나의 클라이언트 엔드포인트가 있다.

- Redirection endpoint(리다이렉션 엔드포인트) 인가 서버가 리소스 소유자의 사용자 에이전트를 통해 인가 자격 증명을 포함한 응답을 클라이언트에게 반환하기 위해 사용하는 엔드포인트

모든 인가 승인 유형이 이 두 엔드포인트를 모두 사용하는 것은 아니다. 확장 인가 승인 유형(extension grant types)은 필요에 따라 추가적인 엔드포인트를 정의할 수도 있다(MAY).

### 3.1 인가 엔드포인트
인가 엔드포인트는 리소스 소유자와 상호작용하여 인가 승인 정보(authorization grant)를 얻기 위해 사용된다. 인가 서버는 반드시 먼저 리소스 소유자의 신원을 확인해야 한다(MUST). 인가 서버가 리소스 소유자를 인증하는 방식 (예: 사용자 이름과 비밀번호 로그인, 세션 쿠키 등)은 이 명세의 범위를 벗어난다.

클라이언트가 인가 엔드포인트의 위치를 얻는 방법 역시 이 명세의 범위를 벗어나지만 그 위치는 보통 서비스 문서에 제공된다.

엔드포인트 URI는 부록 B에 정의된 대로 “application/x-www-form-urlencoded” 형식으로 포맷된 쿼리 구성 요소([RFC3986] 3.4절)를 포함할 수도 있다(MAY). 이 경우, 추가적인 쿼리 파라미터를 추가할 때 기존 쿼리 구성 요소는 반드시 유지되어야 한다(MUST). 엔드포인트 URI는 프래그먼트(fragment) 구성 요소를 포함해서는 안 된다(MUST NOT).

인가 엔드포인트로의 요청은 사용자 인증과 평문(clear-text) 자격 증명의 전송을 초래하므로(HTTP 응답에서) 인가 서버는 섹션 1.6에 설명된 대로 인가 엔드포인트로 요청을 보낼 때 TLS 사용을 반드시 요구해야 한다(MUST).

인가 서버는 인가 엔드포인트에 대해 HTTP “GET” 메서드[RFC2616]의 사용을 반드시 지원해야 하며(MUST), “POST” 메서드의 사용도 지원할 수 있다(MAY).

값이 없는 상태로 전송된 파라미터는 요청에서 생략된 것처럼 처리되어야 한다(MUST). 인가 서버는 인식하지 못하는 요청 파라미터를 무시해야 한다(MUST). 요청과 응답 파라미터는 한 번을 초과하여 포함되어서는 안 된다(MUST NOT).

#### 3.1.1 응답 유형
인가 엔드포인트는 인가 코드 승인 방식(authorization code grant)과 암시적 승인 방식(implicit grant) 흐름에서 사용된다. 클라이언트는
다음 파라미터를 사용하여 원하는 승인 유형(grant type)을 인가 서버에 알린다.

- response_type 
  - 필수(REQUIRED)이다. 이 값은 반드시 다음 중 하나여야 한다. 섹션 4.1.1에 설명된 대로 인가 코드를 요청하기 위한 "code" 섹션 4.2.1에 설명된 대로 액세스 토큰을 요청하기 위한 "token" (암시적 승인 방식)또는 섹션 8.4에 설명된 대로 등록된 확장 값(registered extension value)

확장 응답 유형(extension response types)은 공백으로 구분된(%x20)여러 값의 목록을 포함할 수도 있다(MAY). 이 경우 값들의 순서는 중요하지 않다(예: "a b"와 "b a"는 동일하다). 이러한 복합 응답 유형의 의미는 각각의 해당 명세에서 정의된다.

인가 요청에 response_type 파라미터가 누락되었거나, 인가 서버가 이해할 수 없는 값인 경우, 인가 서버는 섹션 4.1.2.1에 설명된 대로 오류 응답을 반드시 반환해야 한다(MUST).

#### 3.1.2 리다이렉션 엔드포인트
리소스 소유자와의 상호작용을 마친 후, 인가 서버는 리소스 소유자의 사용자 에이전트를 다시 클라이언트로 이동시킨다. 인가 서버는 클라이언트 등록 과정 중에 또는 인가 요청을 보낼 때 미리 인가 서버와 설정된 클라이언트의 리다이렉션 엔드포인트로 사용자 에이전트를 리다이렉트한다.

리다이렉션 엔드포인트 URI는 [RFC3986] 4.3절에 정의된 대로 반드시 절대 URI(absolute URI)여야 한다(MUST). 엔드포인트 URI는 부록 B에 따라 “application/x-www-form-urlencoded” 형식으로 포맷된 쿼리 구성 요소([RFC3986] 3.4절)를 포함할 수도 있다(MAY). 이 경우, 추가적인 쿼리 파라미터를 추가할 때 기존 쿼리 구성 요소는 반드시 유지되어야 한다(MUST). 엔드포인트 URI는 프래그먼트(fragment) 구성 요소를 포함해서는 안 된다(MUST NOT).

##### 3.1.2.1 엔드포인트 요청 기밀성(추가)
리다이렉션 엔드포인트는, 요청된 응답 유형이 "code" 또는 "token"인 경우이거나, 또는 리다이렉션 요청이 개방된 네트워크를 통해 민감한 자격 증명의 전송을 초래하는 경우에는, 섹션 1.6에 설명된 대로 TLS 사용을 요구하는 것이 바람직하 (SHOULD). 이 명세는 TLS 사용을 의무화하지 않는데, 이는 이 문서가 작성된 시점에서 클라이언트에게 TLS 배포를 요구하는 것이 많은 클라이언트 개발자들에게 상당한 장애물이 되었기 때문이다. TLS를 사용할 수 없는 경우, 인가 서버는 리다이렉션에 앞서 해당 엔드포인트가 안전하지 않다는 점을 리소스 소유자에게 경고하는 것이 바람직하다(SHOULD)(예: 인가 요청 중 메시지를 표시).

전송 계층 보안이 없는 경우는, 클라이언트와 그 클라이언트가 접근 권한을 부여받은 보호된 리소스의 보안에 심각한 영향을 미칠 수 있다. 전송 계층 보안의 사용은 특히, 인가 과정이 클라이언트에 의해 위임된 최종 사용자 인증의 한 형태로 사용되는 경우(예: 제3자 로그인 서비스)에 중요하다.


##### 3.1.2.2 등록 요구 사항
인가 서버는 다음에 해당하는 클라이언트에 대해 리다이렉션 엔드포인트를 반드시 등록하도록 요구해야 한다(MUST).

- 공개 클라이언트(public clients)
- 암시적 승인 방식(implicit grant type)을 사용하는 기밀 클라이언트

인가 서버는 모든 클라이언트가 인가 엔드포인트를 사용하기 전에 리다이렉션 엔드포인트를 등록하도록 요구하는 것이 바람직하다(SHOULD).

인가 서버는 클라이언트가 완전한 리다이렉션 URI 전체를 제공하도록 요구하는 것이 바람직하다(SHOULD) (클라이언트는 요청별 맞춤 처리를 위해 state 요청 파라미터를 사용할 수 있다(MAY)). 만약 완전한 리다이렉션 URI의 등록을 요구하는 것이 불가능한 경우, 인가 서버는 URI 스킴(scheme), 권한(authority), 경로(path)의 등록을 요구하는 것이 바람직하다(SHOULD) (이 경우 클라이언트는 인가 요청 시 리다이렉션 URI의 쿼리 구성 요소만을 동적으로 변경할 수 있다).

인가 서버는 클라이언트가 여러 개의 리다이렉션 엔드포인트를 등록하는 것을 허용할 수 있다(MAY).

리다이렉션 URI 등록 요구 사항이 없는 경우, 섹션 10.15에 설명된 바와 같이
공격자가 인가 엔드포인트를 개방형 리다이렉터(open redirector)로 사용할 수 있게 될 수 있다.

##### 3.1.2.3 동적 구성
여러 개의 리다이렉션 URI가 등록되어 있는 경우, 리다이렉션 URI의 일부만 등록되어 있는 경우, 또는 리다이렉션 URI가 전혀 등록되어 있지 않은 경우에는, 클라이언트는 인가 요청 시 "redirect_uri" 요청 파라미터를 사용하여 반드시 리다이렉션 URI를 포함해야 한다(MUST).

인가 요청에 리다이렉션 URI가 포함된 경우, 인가 서버는 리다이렉션 URI가 하나 이상 등록되어 있다면, 수신한 값이 등록된 리다이렉션 URI(또는 URI 구성 요소) 중 최소 하나와 일치하는지를 [RFC3986] 섹션 6에 정의된 방식에 따라 반드시 비교하고 일치 여부를 확인해야 한다(MUST). 클라이언트 등록 시 완전한 리다이렉션 URI가 포함되어 있었다면, 인가 서버는 [RFC3986] 섹션 6.2.1에 정의된 단순 문자열 비교(simple string comparison) 방식으로 두 URI를 반드시 비교해야 한다(MUST).

##### 3.1.2.4 유효하지 않은 엔드포인트
인가 요청이 누락되었거나, 유효하지 않거나, 또는 일치하지 않는 리다이렉션 URI로 인해 검증에 실패한 경우, 인가 서버는 리소스 소유자에게 해당 오류를 알려야 하며(SHOULD), 유효하지 않은 리다이렉션 URI로 사용자 에이전트를 자동으로 리다이렉트해서는 안 된다(MUST NOT).

##### 3.1.2.5 엔드포인트 콘텐츠
클라이언트의 엔드포인트로 전달되는 리다이렉션 요청은 일반적으로 사용자 에이전트에 의해 처리되는 HTML 문서 응답을 생성한다. 만약 이 HTML 응답이 리다이렉션 요청의 결과로 직접 제공되는 경우, HTML 문서에 포함된 어떠한 스크립트라도 리다이렉션 URI와 그 안에 포함된 자격 증명에 대해 완전한 접근 권한을 가지고 실행된다.

클라이언트는 리다이렉션 엔드포인트 응답에 제3자 스크립트(예: 외부 분석 도구, 소셜 플러그인, 광고 네트워크)를 포함하지 않는 것이 바람직하다(SHOULD NOT). 대신, 클라이언트는 URI로부터 자격 증명을 추출한 뒤, 그 자격 증명을 URI나 다른 위치에 노출하지 않고 사용자 에이전트를 다시 다른 엔드포인트로 리다이렉트하는 것이 바람직하다(SHOULD). 만약 제3자 스크립트가 포함된다면, 클라이언트는 URI로부터 자격 증명을 추출하고 제거하는 데 사용되는 자신의 스크립트가 반드시 먼저 실행되도록 보장해야 한다(MUST).

### 3.2 토큰 엔드포인트
토큰 엔드포인트는 클라이언트가 자신의 권한 부여 승인 정보(authorization grant) 또는 리프레시 토큰(refresh token)을 제시하여 액세스 토큰을 얻기 위해 사용하는 엔드포인트이다. 토큰 엔드포인트는 암시적 승인 방식(implicit grant type)을 제외한 모든 권한 부여 방식에서 사용된다(암시적 승인 방식에서는 액세스 토큰이 직접 발급되기 때문이다).

클라이언트가 토큰 엔드포인트의 위치를 얻는 방법은 이 명세의 범위를 벗어나지만, 해당 위치는 일반적으로 서비스 문서에 제공된다.

엔드포인트 URI는 부록 B에 따라 "application/x-www-form-urlencoded" 형식으로 포맷된 쿼리 구성 요소([RFC3986] 섹션 3.4)를 포함할 수 있다(MAY). 이 경우, 추가적인 쿼리 파라미터를 추가할 때 해당 쿼리 구성 요소는 반드시 유지되어야 한다(MUST). 엔드포인트 URI에는 프래그먼트(fragment) 구성 요소가 포함되어서는 안 된다(MUST NOT).

토큰 엔드포인트로의 요청은 HTTP 요청과 응답에서 평문 자격 증명의 전송을 발생시키므로, 인가 서버는 섹션 1.6에 설명된 대로 토큰 엔드포인트로 요청을 보낼 때 TLS 사용을 반드시 요구해야 한다(MUST).

클라이언트는 액세스 토큰 요청을 수행할 때 HTTP "POST" 메서드를 반드시 사용해야 한다(MUST).

값이 없는 상태로 전송된 파라미터는 요청에서 생략된 것처럼 처리되어야 한다(MUST). 인가 서버는 인식할 수 없는 요청 파라미터를 반드시 무시해야 한다(MUST). 요청 및 응답 파라미터는 한 번을 초과하여 포함되어서는 안 된다(MUST NOT).

#### 3.2.1 클라이언트 인증
기밀 클라이언트(confidential clients) 또는 클라이언트 자격 증명(client credentials)이 발급된 다른 클라이언트는, 토큰 엔드포인트에 요청을 보낼 때 2.3절에 설명된 방식에 따라 반드시 인가 서버와 인증해야 한다(MUST). 클라이언트 인증은 다음과 같은 목적을 위해 사용된다.

- 리프레시 토큰과 인가 코드(authorization code)를 그것들이 발급된 클라이언트에 묶어 두기(binding) 위함이다.
클라이언트 인증은 특히, 인가 코드가 안전하지 않은 채널을 통해 리다이렉션 엔드포인트로 전송되는 경우나, 리다이렉션 URI가 완전히 등록되지 않은 경우에 매우 중요하다.
- 손상(compromised)된 클라이언트로부터 복구하기 위함이다. 즉, 클라이언트를 비활성화하거나 그 자격 증명을 변경함으로써, 공격자가 탈취한 리프레시 토큰을 악용하는 것을 방지한다. 하나의 클라이언트 자격 증명 집합을 변경하는 것은, 전체 리프레시 토큰 집합을 철회(revoke)하는 것보다 훨씬 빠르다.
- 주기적인 자격 증명 교체(credential rotation)를 요구하는 인증 관리 모범 사례(best practices)를 구현하기 위함이다. 전체 리프레시 토큰 집합을 교체하는 것은 어려울 수 있지만, 하나의 클라이언트 자격 증명 집합을 교체하는 것은 훨씬 쉽다.

클라이언트는 토큰 엔드포인트로 요청을 보낼 때, "client_id" 요청 파라미터를 사용하여 자신을 식별할 수도 있다(MAY). "authorization_code" "grant_type" 요청에서, 인증되지 않은 클라이언트는 다른 "client_id"를 가진 클라이언트를 위해 발급된 코드를 실수로 받아들이는 것을 방지하기 위해 반드시 "client_id"를 전송해야 한다(MUST). 이는 인증 코드 치환(substitution)을 방지하기 위한 것이다. (이 조치는 보호된 리소스에 대해 추가적인 보안을 제공하지는 않는다.)

### 3.3 액세스 토큰 범위
인가 엔드포인트와 토큰 엔드포인트는, 클라이언트가 "scope" 요청 파라미터를 사용하여 접근 요청의 범위(scope)를 지정할 수 있도록 허용한다. 이에 따라 인가 서버는 발급된 액세스 토큰의 범위를 클라이언트에게 알리기 위해 "scope" 응답 파라미터를 사용한다.

scope 파라미터의 값은 공백으로 구분된(case-sensitive한) 문자열들의 목록으로 표현된다. 이 문자열들은 인가 서버에 의해 정의된다.
값이 여러 개의 공백으로 구분된 문자열을 포함하는 경우, 문자열들의 순서는 중요하지 않으며, 각 문자열은 요청된 범위에 추가적인 접근 범위를 더한다.

```
scope       = scope-token *( SP scope-token )
scope-token = 1*( %x21 / %x23-5B / %x5D-7E )
```
(위는 scope 값이 어떤 문자들로 구성될 수 있는지를 정의한 문법이다.)

인가 서버는 인가 서버의 정책이나 리소스 소유자의 지침에 따라, 클라이언트가 요청한 scope를 전체 또는 일부 무시할 수 있다(MAY). 만약 발급된 액세스 토큰의 scope가 클라이언트가 요청한 scope와 다르다면, 인가 서버는 실제로 부여된 범위를 클라이언트에게 알리기 위해 "scope" 응답 파라미터를 반드시 포함해야 한다(MUST).

클라이언트가 인가 요청 시 scope 파라미터를 생략한 경우, 인가 서버는 반드시 다음 중 하나를 수행해야 한다(MUST). 미리 정의된 기본(default) scope 값을 사용하여 요청을 처리하거나 scope가 유효하지 않음을 나타내며 요청을 실패시킨다 인가 서버는 자신이 요구하는 scope 조건과 기본 scope 값(정의되어 있다면)을 문서로 명시하는 것이 바람직하다(SHOULD).