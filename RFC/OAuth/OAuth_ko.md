# The OAuth 2.0 Authorization Framework
인터넷 표준을 제정 / 관리하는 국제 표준화 기구                                                                  편집자는 D.Hardt
RFC 문서 번호 6749                                                                                     소속기관: 마이크로소프트
이 문서는 RFC 5849를 폐기하고 대체함 즉, 6749가 최신 표준이고 5849는 더 이상 사용 권장되지 않음                        문서발표일 2012년 10월
인터넷 공식 표준으로 채택되는 과정에 있는 문서
RFC 시리즈 전체에 부여된 국제 표준 연속간행물번호

### 초록 (Abstract)
OAuth 2.0 권한 부여 프레임워크를 사용하면 타사 애플리케이션이 HTTP 서비스에 대한 제한된 액세스 권한을 얻을 수 있습니다. 이는 리소스 소유자와 HTTP 서비스 간의 승인 상호 작용을 조정하여 리소스 소유자를 대신해 액세스 권한을 얻거나, 타사 애플리케이션이 직접 액세스 권한을 얻도록 허용하는 방식으로 이루어질 수 있습니다. 이 사양은 RFC 5849에 설명된 OAuth 1.0 프로토콜을 대체하고 더 이상 사용하지 않도록 합니다.

### 이 문서의 상태(Status of This Memo)

이 문서는 인터넷 표준 트랙 문서입니다.

이 문서는 인터넷 엔지니어링 태스크 포스(IETF)의 산물이며, IETF 커뮤니티의 합의를 반영합니다. 공개 검토를 거쳐 인터넷 엔지니어링 운영 그룹(IESG)의 승인을 받아 발행되었습니다. 인터넷 표준에 대한 자세한 정보는 RFC 5741의 2절에서 확인할 수 있습니다.

이 문서의 현재 상태, 오류 수정 사항 및 의견 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc6749에서 확인할 수 있습니다.

### 저작권 고지(Copyright Notice)
저작권(c) 2012 IETF Trust 및 문서 작성자로 명시된 개인. 모든 권리 보유.

이 문서는 BCP 78 및 이 문서 발행일 현재 유효한 IETF 신탁의 IETF 문서 관련 법적 조항(http://trustee.ietf.org/license-info)의 적용을 받습니다. 이 문서와 관련하여 귀하의 권리와 제한 사항이 명시되어 있으므로 해당 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소에는 신탁 법적 조항 4.e항에 설명된 간소화된 BSD 라이선스 텍스트가 포함되어야 하며, 간소화된 BSD 라이선스에 명시된 바와 같이 어떠한 보증도 없이 제공됩니다.

## 목차
1. [소개](#1-소개)
    - 1.1. [역할](#11-역할)
    - 1.2. [프르토콜 흐름](#12-프로토콜-흐름)
    - 1.3. [권한 부여 방식](#13-인가-승인) 
      - 1.3.1. [인가 코드](#131-인가-코드)
      - 1.3.2. [암시적 권한 부여 방식](#132-암시적-권한-부여-방식) 
      - 1.3.3. [리소스 소유자 비밀번호 자격 증명 방식](#133-리소스-소유자-비밀번호-자격-증명)
      - 1.3.4. [클라이언트 자격 증명](#134-클라이언트-자격-증명)
    - 1.4. [Access Token](#14-access-token) 
    - 1.5. [Refresh Token](#15-refresh-token)
    - 1.6. [TLS 버전](#16-tls-버전)
    - 1.7. [HTTP 리디렉션](#17-http-리디렉션)
    - 1.8. [상호 운용성](#18-상호-운용성)
    - 1.9. [표기 규칙](#19-표기-규칙)
2. [클라이언트 등록](#2-클라이언트-등록)
    - 2.1. [클라이언트 유형](#21-클라이언트-유형)
    - 2.2. [클라이언트 식별자](#22-클라이언트-식별자)
    - 2.3. [클라이언트 인증](#23-클라이언트-인증)
      - 2.3.1. 클라이언트 비밀번호 방식 
      - 2.3.2. 기타 인증 방식 
    - 2.4. 미등록 클라이언트 
3. 프로토콜 엔드포인트
    - 3.1. 인가(권한 부여 엔드포인트) 
      - 3.1.1. 응용 타입 
      - 3.1.2. 리다이렉션 엔드 포인트 
    - 3.2. 토큰 엔드포인트
      - 3.2.1. 클라이언트 인증
    - 3.3. 액세스 토큰 범위 
4. 권한 획득 방법 
    - 4.1. 인가 코드 방식 
      - 4.1.1. 인가 요청 
      - 4.1.2. 인가 응답 
      - 4.1.3. 액세스 토큰 요청 
      - 4.1.4. 액세스 토큰 응답 
    - 4.2. Implicit 방식
      - 4.2.1. 인가 요청 
      - 4.2.2. 리소스 소유자 비밀번호 방식 
    - 4.3. 리소스 소유자 비밀번호 방식 
      - 4.3.1. 인가 요청 및 응답 
      - 4.3.2. 액세스 토큰 요청 
      - 4.3.3. 액세스 토큰 응답 
    - 4.4. 클라이언트 자격 증명 방식
      - 4.4.1. 인가 요청 및 응답
      - 4.4.2. 인가 요청 및 응답
      - 4.4.3. 액세스 토큰 응답
    - 4.5. 확장 그랜트
5. 액세스 토큰 발급 
    - 5.1. Successful Response
    - 5.2. Error Response 
6. 액세스 토큰 갱신 
7. 보호된 리소스 접근 
    - 7.1. 액세스 토큰 유형 
    - 7.2. Error Response
8. 확장성 
    - 8.1. 액세스 토큰 타입 정의 
    - 8.2. 새 엔드 포인트 파라미터 정의
    - 8.3. 새 권한 부여 방식 정의 
    - 8.4. 새 인가 엔드포인트 응답 타입 정의 
    - 8.5. 추가 오류 코드 정의 
9. 네이티브 애플리케이션 
10. 보안 고려 사항
    - 10.1. 클라이언트 인증 보안
    - 10.2. 클라이언트 사칭
    - 10.3. Access Tokens 
    - 10.4. Refresh Tokens
    - 10.5. Authorization Codes 
    - 10.6. 인가 코드 리다이렉트 URI 조작 
    - 10.7. 리소스 소유자 비밀번호 방식의 보안 문제 
    - 10.8. 요청 기밀성 
    - 10.9. 엔드포인트 진위 확인 
    - 10.10. 자격 증명 추측 공격
    - 10.11. 피싱 공격 
    - 10.12. 사이트 간 요청 위조 공격 
    - 10.13. 클릭재킹 공격 
    - 10.14. 코드 주입 및 입력값 검증 
    - 10.15. 오픈 리다이렉터 취약점 
    - 10.16. Implicit 방식에서 액세스 토큰을 악용해 사용자를 사칭하는 문제
11. IANA 관련 사항 
    - 11.1. OAuth 액세스 토큰 타입 등록소
      - 11.1.1. 등록 양식 
    - 11.2. Oauth 파라미터 등록소 
      - 11.2.1. 등록 양식 
      - 11.2.2. 초기 등록 목록 
    - 11.3. Oauth인가 엔드포인트 응답 타입 등록소
      - 11.3.1. 등록 양식
      - 11.3.2. 초기 등록 목록 
    - 11.4. Oauth 확장 오류 등록소
      - 11.4.1. 등록 양식
12. 참고 문헌
    - 12.1. 규범적 참고 문헌 
    - 12.2. 정보 제공용 참고 문헌
13. 부록 A. 확장된 BNF(ABNF) 문법
    - A.1.  "client_id" 문법 
    - A.2.  "client_secret" 문법 
    - A.3.  "response_type" 문법 
    - A.4.  "scope" 문법 
    - A.5.  "state" 문법
    - A.6.  "redirect_uri" 문법 
    - A.7.  "error" 문법
    - A.8.  "error_description" 문법
    - A.9.  "error_uri" 문법 
    - A.10. "grant_type" 문법 
    - A.11. "code" 문법 
    - A.12. "access_token" 문법 
    - A.13. "token_type" 문법 
    - A.14. "expires_in" 문법 
    - A.15. "username" 문법 
    - A.16. "password" 문법 
    - A.17. "refresh_token" 문법 
    - A.18. Endpoint Parameter 문법
14. 부록 B. application/x-www-form-urlencoded 미디어 타입 사용 
15. 부록 C. 감사의 글 

## 1. 소개
기존의 클라이언트-서버 인증 모델에서 클라이언트는 리소스 소유자의 자격 증명을 사용하여 서버에 인증함으로써 접근이 제한된 리소스(보호된 리소스)에 대한 접근을 요청합니다. 제3자 애플리케이션이 제한된 리소스에 접근할 수 있도록 하려면 리소스 소유자는 자신의 자격 증명을 제3자와 공유해야 합니다. 하지만 이로 인해 다음과 같은 몇 가지 문제점과 한계가 발생합니다.

- 타사 애플리케이션은 리소스 소유자의 자격 증명(일반적으로 평문으로 저장된 암호)을 향후 사용을 위해 저장해야 합니다.
- 서버는 암호에 내재된 보안 취약점에도 불구하고 암호 인증을 지원해야 합니다.
- 타사 애플리케이션은 리소스 소유자의 보호된 리소스에 대해 지나치게 광범위한 접근 권한을 획득하여, 리소스 소유자가 접근 기간이나 접근 범위를 리소스의 일부로 제한할 수 없게 됩니다.
- 리소스 소유자는 개별 타사의 접근 권한을 취소할 수 없으며, 모든 타사의 접근 권한을 취소하지 않고는 해당 타사의 접근 권한을 취소할 수 없습니다. 따라서 타사의 암호를 변경해야 합니다.
- 타사 애플리케이션이 손상되면 최종 사용자의 암호와 해당 암호로 보호되는 모든 데이터가 손상됩니다.

OAuth는 권한 부여 계층을 도입하고 클라이언트와 리소스 소유자의 역할을 분리함으로써 이러한 문제를 해결합니다. OAuth에서 클라이언트는 리소스 소유자가 관리하고 리소스 서버에서 호스팅하는 리소스에 대한 접근을 요청하고, 리소스 소유자와는 다른 자격 증명 세트를 발급받습니다.

클라이언트는 보호된 리소스에 접근할 때 리소스 소유자의 자격 증명을 사용하는 대신, 특정 범위, 유효 기간 및 기타 접근 속성을 나타내는 문자열인 액세스 토큰을 획득합니다. 액세스 토큰은 리소스 소유자의 승인을 받아 권한 부여 서버에서 제3자 클라이언트에게 발급됩니다. 클라이언트는 이 액세스 토큰을 사용하여 리소스 서버에서 호스팅하는 보호된 리소스에 접근합니다.

예를 들어, 최종 사용자(리소스 소유자)는 사진 공유 서비스(리소스 서버)에 저장된 보호된 사진에 대한 접근 권한을 인쇄 서비스(클라이언트)에 부여할 수 있습니다. 이때 사용자 이름과 비밀번호를 인쇄 서비스와 공유할 필요는 없습니다. 대신, 사진 공유 서비스에서 신뢰하는 서버(권한 부여 서버)에 직접 인증하여 인쇄 서비스에 대한 위임 전용 자격 증명(액세스 토큰)을 발급받습니다.

이 사양은 HTTP([RFC2616])와 함께 사용하도록 설계되었습니다.
HTTP 이외의 프로토콜을 통한 OAuth 사용은 이 사양의 범위를 벗어납니다.

정보 문서로 발표된 OAuth 1.0 프로토콜([RFC5849])은 소규모 임시 커뮤니티의 노력으로 탄생했습니다. 이 표준 트랙 사양은 OAuth 1.0 배포 경험과 더 넓은 IETF 커뮤니티에서 수집한 추가 사용 사례 및 확장성 요구 사항을 기반으로 합니다. OAuth 2.0 프로토콜은 OAuth 1.0과 하위 호환되지 않습니다. 두 버전은 네트워크에서 공존할 수 있으며, 구현체는 둘 다 지원하도록 선택할 수 있습니다. 그러나 이 사양의 의도는 새로운 구현체가 이 문서에 명시된 대로 OAuth 2.0을 지원하고 OAuth 1.0은 기존 배포를 지원하는 데에만 사용하도록 하는 것입니다. OAuth 2.0 프로토콜은 OAuth 1.0 프로토콜과 구현 세부 사항을 거의 공유하지 않습니다. OAuth 1.0에 익숙한 구현체는 이 문서의 구조와 세부 사항에 대한 어떠한 가정도 없이 접근해야 합니다.

### 1.1 역할
OAuth는 다음과 같은 네 가지 역할을 정의합니다.

1. 리소스 소유자
- 보호된 리소스에 대한 접근 권한을 부여할 수 있는 주체. 리소스 소유자가 사람인 경우, 최종 사용자라고 합니다.

2. 리소스 서버
- 보호된 리소스를 호스팅하고, 액세스 토큰을 사용하여 보호된 리소스 요청을 수락하고 응답할 수 있는 서버.

3. 클라이언트 
- 리소스 소유자를 대신하여 권한을 부여받아 보호된 리소스에 대한 요청을 하는 애플리케이션.
"클라이언트"라는 용어는 특정 구현 특성(예: 서버, 데스크톱 또는 기타 장치에서 실행되는지 여부)을 의미하지 않습니다.

4. 권한 부여 서버
- 리소스 소유자를 성공적으로 인증하고 권한을 획득한 후 클라이언트에게 액세스 토큰을 발급하는 서버.

권한 부여 서버와 리소스 서버 간의 상호 작용은 이 사양의 범위를 벗어납니다. 권한 부여 서버는 리소스 서버와 동일한 서버일 수도 있고, 별도의 개체일 수도 있습니다. 단일 권한 부여 서버는 여러 리소스 서버에서 허용되는 액세스 토큰을 발급할 수 있습니다.

### 1.2 프로토콜 흐름

```
     +--------+                                  +---------------+
     |        |---------(A)- 인가 요청------------>|   리소스 소유자  |
     |        |                                  |               |
     |        |<-(B)-- 인가 승인 정보(권한 부여 결과)---|               |
     |        |                                  +---------------+
     |        |
     |        |                                  +--------------+
     |        |--(C)-- 인가 승인 정보(권한 부여 결과)-->|    인가 서버    |
     | 클라이언트|                                  |               |
     |        |<-(D)----- Access Token ----------|               |
     |        |                                  +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    리소스 서버   |
     |        |                               |               |
     |        |<-(F)-------보호된 리소스---------|               |
     +--------+                               +---------------+

                     그림 1: 추상적인 프로토콜 흐름
```
그림 1에 나타낸 추상적인 OAuth 2.0 흐름은 네 가지 역할 간의 상호 작용을 설명하며 다음과 같은 단계를 포함합니다.

(A) 클라이언트는 리소스 소유자에게 권한 부여를 요청합니다. 권한 부여 요청은 리소스 소유자에게 직접 (그림과 같이) 또는 (가급적이면) 권한 부여 서버를 통해 간접적으로 수행할 수 있습니다.
(B) 클라이언트는 권한 부여 부여(authorization grant)를 수신합니다. 이는 리소스 소유자의 권한을 나타내는 자격 증명으로, 이 명세에 정의된 네 가지 부여 유형 중 하나 또는 확장 부여 유형을 사용하여 표현됩니다. 권한 부여 부여 유형은 클라이언트가 권한을 요청하는 데 사용한 방법과 권한 부여 서버에서 지원하는 유형에 따라 달라집니다.
(C) 클라이언트는 권한 부여 서버에 인증하고 권한 부여 부여를 제시하여 액세스 토큰을 요청합니다.
(D) 권한 부여 서버는 클라이언트를 인증하고 권한 부여를 검증하며, 유효한 경우 액세스 토큰을 발급합니다.
(E) 클라이언트는 리소스 서버에 보호된 리소스를 요청하고 액세스 토큰을 제시하여 인증합니다.
(F) 리소스 서버는 액세스 토큰을 검증하고, 유효한 경우 요청을 처리합니다.

클라이언트가 리소스 소유자로부터 권한 부여를 얻는 데 선호되는 방법(단계 (A) 및 (B)에 설명됨)은 권한 부여 서버를 중개자로 사용하는 것이며 이는 섹션 4.1의 그림 3에 설명되어 있습니다.

### 1.3 권한 부여 방식
권한 부여는 클라이언트가 액세스 토큰을 얻기 위해 사용하는 리소스 소유자의 권한(보호된 리소스에 접근할 수 있는 권한)을 나타내는 자격 증명입니다. 이 사양에서는 권한 부여 코드, 암시적, 리소스 소유자 암호 자격 증명 및 클라이언트 자격 증명의 네 가지 부여 유형과 추가 유형을 정의할 수 있는 확장 메커니즘을 정의합니다.

#### 1.3.1 인가 코드
Authorization Code 방식에서는, 클라이언트와 사용자 사이에서 인가 서버가 중간 역할을 한다. 클라이언트는 사용자에게 직접 “권한을 주세요”라고 요청하지 않고, 사용자를 인가 서버로 보내어(브라우저 같은 사용자 에이전트를 통해) 인가 서버가 대신 처리하도록 한다. 인가 서버는 사용자를 인증(로그인)하고 클라이언트가 요청한 권한에 대해 사용자의 동의를 받은 뒤 사용자를 다시 클라이언트로 돌려보내면서 ‘인가 코드(authorization code)’를 전달한다. 이 과정에서 사용자는 오직 인가 서버에만 로그인하기 때문에, 사용자의 아이디와 비밀번호는 클라이언트에 절대 전달되지 않는다.

인증 코드는 클라이언트를 인증하는 기능과 리소스 소유자의 사용자 에이전트를 거치지 않고 액세스 토큰을 클라이언트에 직접 전송하여 리소스 소유자를 포함한 다른 사람에게 노출될 가능성을 줄이는 기능 등 몇 가지 중요한 보안 이점을 제공합니다.

#### 1.3.2 암시적 권한 부여 방식
Implicit Grant(암시적 권한 부여 방식)은 JavaScript와 같은 스크립트 언어를 사용해 브라우저에서 구현된 클라이언트에 최적화된 간소화된 Authorization Code 흐름입니다. Implicit 흐름에서는 클라이언트에게 인가 코드(authorization code)를 발급하는 대신 리소스 소유자의 승인 결과로 액세스 토큰을 직접 발급합니다. 이 방식은 인가 코드와 같은 중간 자격 증명이 발급되지 않고 (그리고 이후에 액세스 토큰을 얻는 데 사용되지도 않기 때문에) grant 타입이 ‘implicit(암시적)’이라고 불린다.


Implicit Grant 흐름에서 액세스 토큰을 발급할 때 인가 서버는 클라이언트를 인증하지 않습니다. 일부 경우에는 액세스 토큰을 클라이언트에 전달하기 위해 사용되는 리다이렉션 URI를 통해 클라이언트의 식별을 확인할 수도 있다. 하지만 액세스 토큰은 리소스 소유자 또는 리소스 소유자의 사용자 에이전트에 접근할 수 있는 다른 애플리케이션에 노출될 수 있다.

Implicit Grant는 액세스 토큰을 얻기 위해 필요한 통신 왕복 횟수를 줄이기 때문에 브라우저 내에서 동작하는 애플리케이션과 같은 일부 클라이언트에서는 응답성과 효율성을 향상시킨다. 그러나 이러한 편의성은 특히 Authorization Code Grant를 사용할 수 있는 경우에는 섹션 10.3과 10.16에서 설명된 것과 같은 Implicit Grant 사용에 따른 보안상의 영향을 충분히 고려한 후에 선택되어야 한다.

#### 1.3.3 리소스 소유자 비밀번호 자격 증명
리소스 소유자의 비밀번호 자격 증명(즉, 사용자 이름과 비밀번호)은 액세스 토큰을 얻기 위한 인가 승인 정보(authorization grant)로서 직접 사용될 수 있다. 이 자격 증명은 리소스 소유자와 클라이언트 사이에 높은 수준의 신뢰가 존재하는 경우에만 사용되어야 하며 (예: 클라이언트가 디바이스 운영체제의 일부이거나, 매우 높은 권한을 가진 애플리케이션인 경우), 그리고 인가 코드와 같은 다른 인가 승인 방식이 사용할 수 없는 경우에만 사용되어야 한다.

이 인가 승인 방식은 클라이언트가 리소스 소유자의 자격 증명에 직접 접근해야 함에도 불구하고 리소스 소유자의 자격 증명은 단 한 번의 요청에만 사용되며 그 이후에는 액세스 토큰으로 교환된다. 이 방식은 자격 증명을 장기적으로 사용 가능한 액세스 토큰이나 리프레시 토큰으로 교환함으로써 클라이언트가 리소스 소유자의 자격 증명을 향후 사용을 위해 저장할 필요를 없앨 수 있다.

#### 1.3.4 클라이언트 자격 증명
클라이언트 자격 증명(또는 다른 형태의 클라이언트 인증 수단)은 인가 범위가 클라이언트의 관리 하에 있는 보호된 리소스로 제한되거나 또는 사전에 인가 서버와 협의된 보호된 리소스에 한정되는 경우 인가 승인 정보(authorization grant)로 사용될 수 있다. 클라이언트 자격 증명은 일반적으로 클라이언트가 자기 자신을 대표하여 동작하는 경우(즉, 클라이언트가 리소스 소유자이기도 한 경우) 또는 인가 서버와 미리 합의된 인가를 기반으로 보호된 리소스에 접근을 요청하는 경우에 인가 승인 정보로 사용된다.

### 1.4 Access Token
액세스 토큰(access token)은 보호된 리소스에 접근하기 위해 사용되는 자격 증명이다. 액세스 토큰은 클라이언트에게 발급된 인가(authorization)를 나타내는 문자열이다. 이 문자열은 보통 클라이언트가 해석할 수 없는 불투명한 값이다. 토큰은 리소스 소유자가 부여한 특정 접근 범위(scope)와 접근 기간(duration)을 나타내며,
이 접근 권한은 리소스 서버와 인가 서버에 의해 강제된다.

이 토큰은 인가 정보를 조회하기 위해 사용되는 식별자(identifier)를 나타낼 수도 있고, 또는 인가 정보를 자체적으로 포함하고 검증 가능한 형태일 수도 있다(즉, 데이터와 서명으로 구성된 토큰 문자열일 수 있다). 이 명세의 범위를 벗어나는 추가적인 인증 자격 증명이 클라이언트가 토큰을 사용하기 위해 요구될 수도 있다.

액세스 토큰은 사용자 이름과 비밀번호와 같은 다양한 인가 수단을 하나의 토큰으로 대체하는 추상화 계층을 제공하며, 이 토큰은 리소스 서버가 이해할 수 있는 단일한 형태로 사용된다. 이러한 추상화는 토큰을 발급받는 데 사용된 인가 승인 정보보다 더 제한적인 권한을 가진 액세스 토큰을 발급할 수 있게 해주며 리소스 서버가 다양한 인증 방식들을 모두 이해할 필요를 없애준다.

액세스 토큰은 리소스 서버의 보안 요구 사항에 따라 서로 다른 형식, 구조, 그리고 사용 방식 (예: 암호학적 속성)을 가질 수 있다. 액세스 토큰의 속성과 보호된 리소스에 접근하는 방법에 대한 상세 내용은 이 명세의 범위를 벗어나며 [RFC6750]과 같은 관련 명세에서 정의된다.

### 1.5 Refresh Token
리프레시 토큰은 액세스 토큰을 얻기 위해 사용되는 자격 증명이다. 리프레시 토큰은 인가 서버가 클라이언트에게 발급하며 현재의 액세스 토큰이 유효하지 않게 되거나 만료되었을 때 또는 동일하거나 더 제한된 범위(scope)를 가진 추가 액세스 토큰을 얻기 위해 사용된다 (액세스 토큰은 리소스 소유자가 허락한 권한보다 더 짧은 수명이나 더 적은 권한을 가질 수 있다). 리프레시 토큰을 발급할지는 인가 서버의 재량에 따라 선택 사항이다. 인가 서버가 리프레시 토큰을 발급하는 경우, 이는 액세스 토큰을 발급할 때 함께 포함된다(즉, 그림 1의 단계 (D)).

리프레시 토큰은 리소스 소유자가 클라이언트에게 부여한 인가를 나타내는 문자열이다. 이 문자열은 보통 클라이언트가 해석할 수 없는 불투명한 값이다. 이 토큰은 인가 정보를 조회하기 위해 사용되는 식별자(identifier)를 나타낸다. 액세스 토큰과 달리 리프레시 토큰은 인가 서버에서만 사용하도록 의도된 것이며 리소스 서버에는 절대 전달되지 않는다.


```
  +--------+                                           +---------------+
  |        |--(A)------- 인가 승인 정보 ----------------->|               |
  |        |                                           |               |
  |        |<-(B)----------- Access Token -------------|               |
  |        |               & Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token ----------->|               |
  |        |                                           |               |
  |        |<-(H)----------- Access Token -------------|               |
  +--------+           & Optional Refresh Token        +---------------+

               Figure 2:  만료된 액세스 토큰 갱신 흐름
```

그림 2에 나타난 흐름은 다음 단계를 포함한다.

(A) 클라이언트는 인가 서버에 인증하고 인가 승인 정보(authorization grant)를 제시하여 액세스 토큰을 요청한다.

(B) 인가 서버는 클라이언트를 인증하고 인가 승인 정보를 검증하며 유효한 경우 액세스 토큰과 리프레시 토큰을 발급한다.

(C) 클라이언트는 액세스 토큰을 제시하여 리소스 서버에 보호된 리소스를 요청한다.

(D) 리소스 서버는 액세스 토큰을 검증하고 유효한 경우 요청을 처리한다.

(E) 액세스 토큰이 만료될 때까지 (C)와 (D) 단계가 반복된다. 클라이언트가 액세스 토큰의 만료를 알고 있다면 (G) 단계로 바로 이동하고 그렇지 않으면 다시 보호된 리소스를 요청한다.

(F) 액세스 토큰이 유효하지 않으므로 리소스 서버는 유효하지 않은 토큰 오류를 반환한다.

(G) 클라이언트는 인가 서버에 인증하고 리프레시 토큰을 제시하여 새로운 액세스 토큰을 요청한다. 클라이언트 인증 요구 사항은 클라이언트 유형과 인가 서버 정책에 따라 달라진다.

(H) 인가 서버는 클라이언트를 인증하고 리프레시 토큰을 검증하며 유효한 경우 새로운 액세스 토큰을 발급하고 (선택적으로) 새로운 리프레시 토큰도 함께 발급한다.

단계 (C), (D), (E), (F)는 7절에서 설명된 바와 같이 이 명세의 범위를 벗어난다.

### 1.6 TLS 버전
이 명세에서 **전송 계층 보안(Transport Layer Security, TLS)**이 사용되는 경우, 적절한 TLS 버전(또는 버전들)은 시간이 지나면서 달라질 수 있으며, 이는 널리 배포된 정도와 알려진 보안 취약점에 따라 결정된다. 이 문서가 작성된 시점에서는, TLS 버전 1.2 [RFC5246]가 가장 최신 버전이지만, 배포된 범위가 매우 제한적이며 구현 환경에서 즉시 사용하기 어려울 수도 있다. TLS 버전 1.0 [RFC2246]은 가장 널리 배포된 버전이며, 가장 폭넓은 상호 운용성을 제공한다.

구현체는 또한, 자신들의 보안 요구 사항을 충족하는 경우에 한해 추가적인 전송 계층 보안 메커니즘을 지원할 수도 있다.

### 1.7 HTTP 리디렉션
이 명세는 HTTP 리다이렉션을 광범위하게 사용하며 이 과정에서 클라이언트 또는 인가 서버가 리소스 소유자의 사용자 에이전트(user-agent)를 다른 목적지로 이동시키도록 지시한다. 이 명세에 포함된 예제들은 HTTP 302 상태 코드를 사용하는 경우를 보여주지만, 사용자 에이전트를 통해 이러한 리다이렉션을 수행할 수 있는 다른 모든 방법 또한 허용되며 이는 **구현 세부 사항(implementation detail)**으로 간주된다.

### 1.8 상호 운용성
OAuth 2.0은 명확하게 정의된 보안 특성을 갖춘 풍부한 인가 프레임워크를 제공한다. 그러나 이 프레임워크는 구성 요소가 많고 선택 사항이 많은 매우 확장 가능한 구조이기 때문에 이 명세만으로는 서로 호환되지 않는 다양한 구현체들이 생길 가능성이 크다.

또한 이 명세는 몇 가지 필수 구성 요소들을 부분적으로만 정의하거나 아예 정의하지 않고 남겨두고 있다(예: 클라이언트 등록, 인가 서버의 기능, 엔드포인트 탐색 등). 이러한 구성 요소들이 없으면 클라이언트는 특정 인가 서버 및 리소스 서버와 상호 운용하기 위해 수동으로 개별 설정을 해야만 한다.

이 프레임워크는 처음부터 향후 작업을 통해 웹 전체 규모에서의 완전한 상호 운용성을 달성하기 위해 필요한 규범적인 프로파일과 확장들이 정의될 것이라는 명확한 기대를 가지고 설계되었다.

### 1.9 표기 규칙
이 명세에서 사용되는 “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, “OPTIONAL”과 같은 핵심 단어들은 [RFC2119]에 설명된 의미로 해석되어야 한다.

이 명세는 [RFC5234]에 정의된 확장 백우스-나우르 형식(Augmented Backus-Naur Form, ABNF)표기법을 사용한다. 또한, “Uniform Resource Identifier (URI): Generic Syntax” [RFC3986]에 정의된 URI-reference 규칙을 포함한다.

일부 보안 관련 용어들은 [RFC4949]에 정의된 의미로 이해되어야 한다. 이러한 용어에는 “attack(공격)”, “authentication(인증)”, “authorization(인가)”, “certificate(인증서)”, “confidentiality(기밀성)”, “credential(자격 증명)”, “encryption(암호화)”, “identity(신원)”, “sign(서명하다)”, “signature(서명)”, “trust(신뢰)”, “validate(유효성 검사)”, “verify(검증)” 등이 포함되며, 이에 한정되지는 않는다.

별도로 명시되지 않는 한, 모든 프로토콜 파라미터 이름과 값은 대소문자를 구분한다.

## 2. 클라이언트 등록
프로토콜을 시작하기 전에, 클라이언트는 **인가 서버에 등록(register)**해야 한다. 클라이언트가 인가 서버에 등록하는 방법은 이 명세의 범위를 벗어나지만, 일반적으로는 HTML 등록 양식을 통한 최종 사용자와의 상호작용을 포함한다.

클라이언트 등록은 반드시 클라이언트와 인가 서버 간의 직접적인 상호작용을 요구하지는 않는다. 인가 서버가 이를 지원하는 경우, 등록은 신뢰를 설정하고 필요한 클라이언트 속성들을 얻기 위한 다른 방법들에 의존할 수 있다(예: 리다이렉션 URI, 클라이언트 유형). 예를 들어, 등록은 자체 발급된(assertion) 또는 제3자가 발급한 assertion을 사용하여 이루어질 수도 있고, 또는 **인가 서버가 신뢰된 채널을 통해 클라이언트를 탐색(discovery)**함으로써 수행될 수도 있다.

클라이언트를 등록할 때,클라이언트 개발자는 반드시 다음을 수행해야 한다(SHALL):
- 섹션 2.1에 설명된 대로 **클라이언트 유형(client type)**을 지정해야 한다.
- 섹션 3.1.2에 설명된 대로 클라이언트 리다이렉션 URI를 제공해야 한다.
- 그리고 인가 서버가 요구하는 기타 모든 정보를 포함해야 한다(예: 애플리케이션 이름, 웹사이트, 설명, 로고 이미지, 법적 약관에 대한 동의).

### 2.1 클라이언트 유형
OAuth는 인가 서버와 안전하게 인증할 수 있는 능력, 즉 클라이언트 자격 증명의 기밀성을 유지할 수 있는 능력을 기준으로 두 가지 클라이언트 유형을 정의한다.

- 기밀 클라이언트(confidential)
기밀 클라이언트는 자신의 자격 증명의 기밀성을 유지할 수 있는 클라이언트이다(예: 클라이언트 자격 증명에 대한 접근이 제한된 보안 서버에서 구현된 클라이언트), 또는 다른 수단을 사용하여 안전한 클라이언트 인증이 가능한 경우를 말한다.

- 공개 클라이언트(public)
공개 클라이언트는 자신의 자격 증명의 기밀성을 유지할 수 없는 클라이언트이다(예: 리소스 소유자가 사용하는 장치에서 실행되는 클라이언트로, 설치형 네이티브 애플리케이션이나 웹 브라우저 기반 애플리케이션 등), 그리고 어떠한 다른 방법으로도 안전한 클라이언트 인증이 불가능한 경우를 말한다.

클라이언트 유형의 지정은
인가 서버가 정의한 안전한 인증 기준과
클라이언트 자격 증명이 노출될 수 있는 허용 수준을 기준으로 한다.
인가 서버는 클라이언트 유형에 대해 임의로 가정해서는 안 된다(SHOULD NOT).


클라이언트는 각각 다른 클라이언트 유형과 보안 환경을 가진 여러 구성 요소로 분산되어 구현될 수도 있다 (예: 기밀 서버 기반 구성 요소와 공개 브라우저 기반 구성 요소를 모두 가진 분산 클라이언트).

인가 서버가 이러한 클라이언트를 지원하지 않거나 등록에 대한 지침을 제공하지 않는 경우, 클라이언트는 각 구성 요소를 별도의 클라이언트로 등록해야 한다(SHOULD).

이 명세는 다음과 같은 클라이언트 프로파일을 기준으로 설계되었다.
- 웹 애플리케이션(web application)
웹 애플리케이션은 웹 서버에서 실행되는 기밀 클라이언트이다. 리소스 소유자는 자신의 장치에 있는 사용자 에이전트에서 렌더링된 HTML 사용자 인터페이스를 통해 이 클라이언트에 접근한다.
클라이언트 자격 증명과 클라이언트에게 발급된 모든 액세스 토큰은 웹 서버에 저장되며, 리소스 소유자에게 노출되거나 접근 가능하지 않다.

- 사용자 에이전트 기반 애플리케이션(user-agent-based application)
사용자 에이전트 기반 애플리케이션은 웹 서버로부터 클라이언트 코드가 다운로드되어 리소스 소유자가 사용하는 장치의 사용자 에이전트(예: 웹 브라우저) 내에서 실행되는 공개 클라이언트이다. 프로토콜 데이터와 자격 증명은 리소스 소유자가 쉽게 접근할 수 있으며 (종종 눈에 보이기도 한다). 이러한 애플리케이션은 사용자 에이전트 내부에 존재하기 때문에, 인가를 요청할 때 사용자 에이전트의 기능을 자연스럽게 활용할 수 있다.

- 사용자 에이전트 기반 애플리케이션(user-agent-based application)
사용자 에이전트 기반 애플리케이션은 웹 서버로부터 클라이언트 코드가 다운로드되어 리소스 소유자가 사용하는 장치의 사용자 에이전트(예: 웹 브라우저) 내에서 실행되는 공개 클라이언트이다. 프로토콜 데이터와 자격 증명은 리소스 소유자가 쉽게 접근할 수 있으며 (종종 눈에 보이기도 한다). 이러한 애플리케이션은 사용자 에이전트 내부에 존재하기 때문에, 인가를 요청할 때 사용자 에이전트의 기능을 자연스럽게 활용할 수 있다.

### 2.2 클라이언트 식별자
인가 서버는 등록된 클라이언트에게 **클라이언트 식별자(client identifier)**를 발급한다. 이 클라이언트 식별자는 클라이언트가 제공한 등록 정보를 나타내는 고유한 문자열이다. 클라이언트 식별자는 비밀 값이 아니며, 리소스 소유자에게 노출된다. 따라서 클라이언트 식별자는 클라이언트 인증을 위해 단독으로 사용되어서는 안 된다(MUST NOT). 클라이언트 식별자는 해당 인가 서버에 대해서만 고유하다.

클라이언트 식별자 문자열의 크기(길이)는 이 명세에서 정의하지 않는다. 클라이언트는 식별자의 크기에 대해 임의로 가정해서는 안 된다. 인가 서버는 자신이 발급하는 모든 식별자의 크기를 문서로 명시하는 것이 바람직하다(SHOULD).

### 2.3 클라이언트 인증
클라이언트 유형이 **기밀 클라이언트(confidential)**인 경우, 클라이언트와 인가 서버는 인가 서버의 보안 요구 사항에 적합한 클라이언트 인증 방법을 설정한다. 인가 서버는 자신의 보안 요구 사항을 충족하는 어떠한 형태의 클라이언트 인증 방식도 받아들일 수 있다(MAY).

기밀 클라이언트는 일반적으로 인가 서버와 인증하기 위해 사용되는 클라이언트 자격 증명 집합을 발급받거나(또는 설정한다) (예: 비밀번호, 공개키/개인키 쌍).

인가 서버는 **공개 클라이언트(public client)**와도 클라이언트 인증 방법을 설정할 수 있다(MAY). 그러나 인가 서버는 클라이언트를 식별하기 위한 목적으로 공개 클라이언트의 인증에 의존해서는 안 된다(MUST NOT).

클라이언트는 각 요청마다 하나를 초과하는 인증 방법을 사용해서는 안 된다(MUST NOT).

### 2.3.1 클라이언트 비밀번호
클라이언트 비밀번호를 보유한 클라이언트는, [RFC2617]에 정의된 HTTP Basic 인증 방식을 사용하여 인가 서버에 인증할 수 있다(MAY). 이때 클라이언트 식별자는 부록 B에 따라 “application/x-www-form-urlencoded” 인코딩 알고리즘으로 인코딩되어 사용자 이름(username)으로 사용되며, 클라이언트 비밀번호는 같은 인코딩 알고리즘으로 인코딩되어 비밀번호(password)로 사용된다. 인가 서버는 클라이언트 비밀번호가 발급된 클라이언트를 인증하기 위해 HTTP Basic 인증 방식을 반드시 지원해야 한다(MUST).

예시 (표시를 위해 줄바꿈을 추가한 것임)
```
Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3
```
대안적으로, 인가 서버는 다음 파라미터를 사용하여 요청 본문(request-body)에 클라이언트 자격 증명을 포함하는 방식을 지원할 수도 있다(MAY).

- client_id
  - 필수(REQUIRED), 섹션 2.2에서 설명된 등록 과정 중 클라이언트에게 발급된 클라이언트 식별자
- client_secret
  - 필수(REQUIRED), 클라이언트 비밀 값, 클라이언트 비밀 값이 빈 문자열인 경우, 클라이언트는 이 파라미터를 생략할 수 있다(MAY)

이 두 파라미터를 사용하여 요청 본문에 클라이언트 자격 증명을 포함하는 방식은 권장되지 않는다(NOT RECOMMENDED). 이 방식은 HTTP Basic 인증 방식(또는 다른 비밀번호 기반 HTTP 인증 방식)을 직접 사용할 수 없는 클라이언트로 제한되어야 한다(SHOULD). 이 파라미터들은 요청 본문에서만 전송될 수 있으며, 요청 URI에는 포함되어서는 안 된다(MUST NOT).

예시: 액세스 토큰을 새로고침하기 위해 (Section 6) 아래와 같은 바디 파라미터를 사용하는 요청
```
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
&client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
```