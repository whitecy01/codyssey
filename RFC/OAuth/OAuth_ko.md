# The OAuth 2.0 Authorization Framework
인터넷 표준을 제정 / 관리하는 국제 표준화 기구                                                                  편집자는 D.Hardt
RFC 문서 번호 6749                                                                                     소속기관: 마이크로소프트
이 문서는 RFC 5849를 폐기하고 대체함 즉, 6749가 최신 표준이고 5849는 더 이상 사용 권장되지 않음                        문서발표일 2012년 10월
인터넷 공식 표준으로 채택되는 과정에 있는 문서
RFC 시리즈 전체에 부여된 국제 표준 연속간행물번호

### 초록 (Abstract)
OAuth 2.0 권한 부여 프레임워크를 사용하면 타사 애플리케이션이 HTTP 서비스에 대한 제한된 액세스 권한을 얻을 수 있습니다. 이는 리소스 소유자와 HTTP 서비스 간의 승인 상호 작용을 조정하여 리소스 소유자를 대신해 액세스 권한을 얻거나, 타사 애플리케이션이 직접 액세스 권한을 얻도록 허용하는 방식으로 이루어질 수 있습니다. 이 사양은 RFC 5849에 설명된 OAuth 1.0 프로토콜을 대체하고 더 이상 사용하지 않도록 합니다.

### 이 문서의 상태(Status of This Memo)

이 문서는 인터넷 표준 트랙 문서입니다.

이 문서는 인터넷 엔지니어링 태스크 포스(IETF)의 산물이며, IETF 커뮤니티의 합의를 반영합니다. 공개 검토를 거쳐 인터넷 엔지니어링 운영 그룹(IESG)의 승인을 받아 발행되었습니다. 인터넷 표준에 대한 자세한 정보는 RFC 5741의 2절에서 확인할 수 있습니다.

이 문서의 현재 상태, 오류 수정 사항 및 의견 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc6749에서 확인할 수 있습니다.

### 저작권 고지(Copyright Notice)
저작권(c) 2012 IETF Trust 및 문서 작성자로 명시된 개인. 모든 권리 보유.

이 문서는 BCP 78 및 이 문서 발행일 현재 유효한 IETF 신탁의 IETF 문서 관련 법적 조항(http://trustee.ietf.org/license-info)의 적용을 받습니다. 이 문서와 관련하여 귀하의 권리와 제한 사항이 명시되어 있으므로 해당 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소에는 신탁 법적 조항 4.e항에 설명된 간소화된 BSD 라이선스 텍스트가 포함되어야 하며, 간소화된 BSD 라이선스에 명시된 바와 같이 어떠한 보증도 없이 제공됩니다.

## 목차
1. [소개](#1-소개)
    1.1. [역할](#11-역할)
    1.2. [프르토콜 흐름](#12-프로토콜-흐름)
    1.3. [권한 부여 방식](#13-인가-승인) 
        1.3.1. [인가 코드](#131-인가-코드)
        1.3.2. [암묵적 승인](#132-암묵적-승인) 
        1.3.3. 리소스 소유자 비밀번호 자격 증명 방식
        1.3.4. 클라이언트 자격 증명 방식
    1.4. Access Token 
    1.5. Refresh Token
    1.6. TLS 버전
    1.7. HTTP Redirections
    1.8. 상호 운용성12
    1.9. 표기 규칙
2. 클라이언트 등록
    2.1. 클라이언트 유형
    2.2. 클라이언트 식별자 
    2.3. 클라이언트 인증
        2.3.1. 클라이언트 비밀번호 방식 
        2.3.2. 기타 인증 방식 
    2.4. 미등록 클라이언트 
3. 프로토콜 엔드포인트...18
    3.1. 인가(권한 부여 엔드포인트) 
        3.1.1. 응용 타입 
        3.1.2. 리다이렉션 엔드 포인트 
    3.2. 토큰 엔드포인트
        3.2.1. 클라이언트 인증
    3.3. 액세스 토큰 범위 
4. 권한 획득 방법 
    4.1. 인가 코드 방식 
        4.1.1. 인가 요청 
        4.1.2. 인가 응답 
        4.1.3. 액세스 토큰 요청 
        4.1.4. 액세스 토큰 응답 
    4.2. Implicit 방식
        4.2.1. 인가 요청 
        4.2.2. 리소스 소유자 비밀번호 방식 
    4.3. 리소스 소유자 비밀번호 방식 
        4.3.1. 인가 요청 및 응답 
        4.3.2. 액세스 토큰 요청 
        4.3.3. 액세스 토큰 응답 
    4.4. 클라이언트 자격 증명 방식
        4.4.1. 인가 요청 및 응답
        4.4.2. 인가 요청 및 응답
        4.4.3. 액세스 토큰 응답
    4.5. 확장 그랜트
5. 액세스 토큰 발급 
    5.1. Successful Response
    5.2. Error Response 
6. 액세스 토큰 갱신 
7. 보호된 리소스 접근 
    7.1. 액세스 토큰 유형 
    7.2. Error Response
8. 확장성 
    8.1. 액세스 토큰 타입 정의 
    8.2. 새 엔드 포인트 파라미터 정의
    8.3. 새 권한 부여 방식 정의 
    8.4. 새 인가 엔드포인트 응답 타입 정의 
    8.5. 추가 오류 코드 정의 
9. 네이티브 애플리케이션 
10. 보안 고려 사항
    10.1. 클라이언트 인증 보안
    10.2. 클라이언트 사칭
    10.3. Access Tokens 
    10.4. Refresh Tokens
    10.5. Authorization Codes 
    10.6. 인가 코드 리다이렉트 URI 조작 
    10.7. 리소스 소유자 비밀번호 방식의 보안 문제 
    10.8. 요청 기밀성 
    10.9. 엔드포인트 진위 확인 
    10.10. 자격 증명 추측 공격
    10.11. 피싱 공격 
    10.12. 사이트 간 요청 위조 공격 
    10.13. 클릭재킹 공격 
    10.14. 코드 주입 및 입력값 검증 
    10.15. 오픈 리다이렉터 취약점 
    10.16. Implicit 방식에서 액세스 토큰을 악용해 사용자를 사칭하는 문제
11. IANA 관련 사항 
    11.1. OAuth 액세스 토큰 타입 등록소
        11.1.1. 등록 양식 
    11.2. Oauth 파라미터 등록소 
        11.2.1. 등록 양식 
        11.2.2. 초기 등록 목록 
    11.3. Oauth인가 엔드포인트 응답 타입 등록소
        11.3.1. 등록 양식
        11.3.2. 초기 등록 목록 
    11.4. Oauth 확장 오류 등록소
        11.4.1. 등록 양식
12.  참고 문헌
  12.1. 규범적 참고 문헌 
  12.2. 정보 제공용 참고 문헌
1.   부록 A. 확장된 BNF(ABNF) 문법
    A.1.  "client_id" 문법 
    A.2.  "client_secret" 문법 
    A.3.  "response_type" 문법 
    A.4.  "scope" 문법 
    A.5.  "state" 문법
    A.6.  "redirect_uri" 문법 
    A.7.  "error" 문법
    A.8.  "error_description" 문법
    A.9.  "error_uri" 문법 
    A.10. "grant_type" 문법 
    A.11. "code" 문법 
    A.12. "access_token" 문법 
    A.13. "token_type" 문법 
    A.14. "expires_in" 문법 
    A.15. "username" 문법 
    A.16. "password" 문법 
    A.17. "refresh_token" 문법 
    A.18. Endpoint Parameter 문법
2.   부록 B. application/x-www-form-urlencoded 미디어 타입 사용 
3.   부록 C. 감사의 글 

## 1. 소개
기존의 클라이언트-서버 인증 모델에서 클라이언트는 리소스 소유자의 자격 증명을 사용하여 서버에 인증함으로써 접근이 제한된 리소스(보호된 리소스)에 대한 접근을 요청합니다. 제3자 애플리케이션이 제한된 리소스에 접근할 수 있도록 하려면 리소스 소유자는 자신의 자격 증명을 제3자와 공유해야 합니다. 하지만 이로 인해 다음과 같은 몇 가지 문제점과 한계가 발생합니다.

- 타사 애플리케이션은 리소스 소유자의 자격 증명(일반적으로 평문으로 저장된 암호)을 향후 사용을 위해 저장해야 합니다.
- 서버는 암호에 내재된 보안 취약점에도 불구하고 암호 인증을 지원해야 합니다.
- 타사 애플리케이션은 리소스 소유자의 보호된 리소스에 대해 지나치게 광범위한 접근 권한을 획득하여, 리소스 소유자가 접근 기간이나 접근 범위를 리소스의 일부로 제한할 수 없게 됩니다.
- 리소스 소유자는 개별 타사의 접근 권한을 취소할 수 없으며, 모든 타사의 접근 권한을 취소하지 않고는 해당 타사의 접근 권한을 취소할 수 없습니다. 따라서 타사의 암호를 변경해야 합니다.
- 타사 애플리케이션이 손상되면 최종 사용자의 암호와 해당 암호로 보호되는 모든 데이터가 손상됩니다.

OAuth는 권한 부여 계층을 도입하고 클라이언트와 리소스 소유자의 역할을 분리함으로써 이러한 문제를 해결합니다. OAuth에서 클라이언트는 리소스 소유자가 관리하고 리소스 서버에서 호스팅하는 리소스에 대한 접근을 요청하고, 리소스 소유자와는 다른 자격 증명 세트를 발급받습니다.

클라이언트는 보호된 리소스에 접근할 때 리소스 소유자의 자격 증명을 사용하는 대신, 특정 범위, 유효 기간 및 기타 접근 속성을 나타내는 문자열인 액세스 토큰을 획득합니다. 액세스 토큰은 리소스 소유자의 승인을 받아 권한 부여 서버에서 제3자 클라이언트에게 발급됩니다. 클라이언트는 이 액세스 토큰을 사용하여 리소스 서버에서 호스팅하는 보호된 리소스에 접근합니다.

예를 들어, 최종 사용자(리소스 소유자)는 사진 공유 서비스(리소스 서버)에 저장된 보호된 사진에 대한 접근 권한을 인쇄 서비스(클라이언트)에 부여할 수 있습니다. 이때 사용자 이름과 비밀번호를 인쇄 서비스와 공유할 필요는 없습니다. 대신, 사진 공유 서비스에서 신뢰하는 서버(권한 부여 서버)에 직접 인증하여 인쇄 서비스에 대한 위임 전용 자격 증명(액세스 토큰)을 발급받습니다.

이 사양은 HTTP([RFC2616])와 함께 사용하도록 설계되었습니다.
HTTP 이외의 프로토콜을 통한 OAuth 사용은 이 사양의 범위를 벗어납니다.

정보 문서로 발표된 OAuth 1.0 프로토콜([RFC5849])은 소규모 임시 커뮤니티의 노력으로 탄생했습니다. 이 표준 트랙 사양은 OAuth 1.0 배포 경험과 더 넓은 IETF 커뮤니티에서 수집한 추가 사용 사례 및 확장성 요구 사항을 기반으로 합니다. OAuth 2.0 프로토콜은 OAuth 1.0과 하위 호환되지 않습니다. 두 버전은 네트워크에서 공존할 수 있으며, 구현체는 둘 다 지원하도록 선택할 수 있습니다. 그러나 이 사양의 의도는 새로운 구현체가 이 문서에 명시된 대로 OAuth 2.0을 지원하고 OAuth 1.0은 기존 배포를 지원하는 데에만 사용하도록 하는 것입니다. OAuth 2.0 프로토콜은 OAuth 1.0 프로토콜과 구현 세부 사항을 거의 공유하지 않습니다. OAuth 1.0에 익숙한 구현체는 이 문서의 구조와 세부 사항에 대한 어떠한 가정도 없이 접근해야 합니다.

### 1.1 역할
OAuth는 다음과 같은 네 가지 역할을 정의합니다.

1. 리소스 소유자
- 보호된 리소스에 대한 접근 권한을 부여할 수 있는 주체. 리소스 소유자가 사람인 경우, 최종 사용자라고 합니다.

2. 리소스 서버
- 보호된 리소스를 호스팅하고, 액세스 토큰을 사용하여 보호된 리소스 요청을 수락하고 응답할 수 있는 서버.

3. 클라이언트 
- 리소스 소유자를 대신하여 권한을 부여받아 보호된 리소스에 대한 요청을 하는 애플리케이션.
"클라이언트"라는 용어는 특정 구현 특성(예: 서버, 데스크톱 또는 기타 장치에서 실행되는지 여부)을 의미하지 않습니다.

4. 권한 부여 서버
- 리소스 소유자를 성공적으로 인증하고 권한을 획득한 후 클라이언트에게 액세스 토큰을 발급하는 서버.

권한 부여 서버와 리소스 서버 간의 상호 작용은 이 사양의 범위를 벗어납니다. 권한 부여 서버는 리소스 서버와 동일한 서버일 수도 있고, 별도의 개체일 수도 있습니다. 단일 권한 부여 서버는 여러 리소스 서버에서 허용되는 액세스 토큰을 발급할 수 있습니다.

### 1.2 프로토콜 흐름

```
     +--------+                                  +---------------+
     |        |---------(A)- 인가 요청------------>|   리소스 소유자  |
     |        |                                  |               |
     |        |<-(B)-- 인가 승인 정보(권한 부여 결과)---|               |
     |        |                                  +---------------+
     |        |
     |        |                                  +--------------+
     |        |--(C)-- 인가 승인 정보(권한 부여 결과)-->|    인가 서버    |
     | 클라이언트|                                  |               |
     |        |<-(D)----- Access Token ----------|               |
     |        |                                  +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    리소스 서버   |
     |        |                               |               |
     |        |<-(F)-------보호된 리소스---------|               |
     +--------+                               +---------------+

                     그림 1: 추상적인 프로토콜 흐름
```
그림 1에 나타낸 추상적인 OAuth 2.0 흐름은 네 가지 역할 간의 상호 작용을 설명하며 다음과 같은 단계를 포함합니다.

(A) 클라이언트는 리소스 소유자에게 권한 부여를 요청합니다. 권한 부여 요청은 리소스 소유자에게 직접 (그림과 같이) 또는 (가급적이면) 권한 부여 서버를 통해 간접적으로 수행할 수 있습니다.
(B) 클라이언트는 권한 부여 부여(authorization grant)를 수신합니다. 이는 리소스 소유자의 권한을 나타내는 자격 증명으로, 이 명세에 정의된 네 가지 부여 유형 중 하나 또는 확장 부여 유형을 사용하여 표현됩니다. 권한 부여 부여 유형은 클라이언트가 권한을 요청하는 데 사용한 방법과 권한 부여 서버에서 지원하는 유형에 따라 달라집니다.
(C) 클라이언트는 권한 부여 서버에 인증하고 권한 부여 부여를 제시하여 액세스 토큰을 요청합니다.
(D) 권한 부여 서버는 클라이언트를 인증하고 권한 부여를 검증하며, 유효한 경우 액세스 토큰을 발급합니다.
(E) 클라이언트는 리소스 서버에 보호된 리소스를 요청하고 액세스 토큰을 제시하여 인증합니다.
(F) 리소스 서버는 액세스 토큰을 검증하고, 유효한 경우 요청을 처리합니다.

클라이언트가 리소스 소유자로부터 권한 부여를 얻는 데 선호되는 방법(단계 (A) 및 (B)에 설명됨)은 권한 부여 서버를 중개자로 사용하는 것이며 이는 섹션 4.1의 그림 3에 설명되어 있습니다.

### 1.3 권한 부여 방식
권한 부여는 클라이언트가 액세스 토큰을 얻기 위해 사용하는 리소스 소유자의 권한(보호된 리소스에 접근할 수 있는 권한)을 나타내는 자격 증명입니다. 이 사양에서는 권한 부여 코드, 암시적, 리소스 소유자 암호 자격 증명 및 클라이언트 자격 증명의 네 가지 부여 유형과 추가 유형을 정의할 수 있는 확장 메커니즘을 정의합니다.

#### 1.3.1 인가 코드
Authorization Code 방식에서는, 클라이언트와 사용자 사이에서 인가 서버가 중간 역할을 한다. 클라이언트는 사용자에게 직접 “권한을 주세요”라고 요청하지 않고, 사용자를 인가 서버로 보내어(브라우저 같은 사용자 에이전트를 통해) 인가 서버가 대신 처리하도록 한다. 인가 서버는 사용자를 인증(로그인)하고 클라이언트가 요청한 권한에 대해 사용자의 동의를 받은 뒤 사용자를 다시 클라이언트로 돌려보내면서 ‘인가 코드(authorization code)’를 전달한다. 이 과정에서 사용자는 오직 인가 서버에만 로그인하기 때문에, 사용자의 아이디와 비밀번호는 클라이언트에 절대 전달되지 않는다.

인증 코드는 클라이언트를 인증하는 기능과 리소스 소유자의 사용자 에이전트를 거치지 않고 액세스 토큰을 클라이언트에 직접 전송하여 리소스 소유자를 포함한 다른 사람에게 노출될 가능성을 줄이는 기능 등 몇 가지 중요한 보안 이점을 제공합니다.

### 1.3.2 암묵적 승인
Implicit Grant(암시적 권한 부여 방식)은 JavaScript와 같은 스크립트 언어를 사용해 브라우저에서 구현된 클라이언트에 최적화된 간소화된 Authorization Code 흐름입니다. Implicit 흐름에서는 클라이언트에게 인가 코드(authorization code)를 발급하는 대신 리소스 소유자의 승인 결과로 액세스 토큰을 직접 발급합니다. 이 방식은 인가 코드와 같은 중간 자격 증명이 발급되지 않고 (그리고 이후에 액세스 토큰을 얻는 데 사용되지도 않기 때문에) grant 타입이 ‘implicit(암시적)’이라고 불린다.


Implicit Grant 흐름에서 액세스 토큰을 발급할 때 인가 서버는 클라이언트를 인증하지 않습니다. 일부 경우에는 액세스 토큰을 클라이언트에 전달하기 위해 사용되는 리다이렉션 URI를 통해 클라이언트의 식별을 확인할 수도 있다. 하지만 액세스 토큰은 리소스 소유자 또는 리소스 소유자의 사용자 에이전트에 접근할 수 있는 다른 애플리케이션에 노출될 수 있다.

Implicit Grant는 액세스 토큰을 얻기 위해 필요한 통신 왕복 횟수를 줄이기 때문에 브라우저 내에서 동작하는 애플리케이션과 같은 일부 클라이언트에서는 응답성과 효율성을 향상시킨다. 그러나 이러한 편의성은 특히 Authorization Code Grant를 사용할 수 있는 경우에는 섹션 10.3과 10.16에서 설명된 것과 같은 Implicit Grant 사용에 따른 보안상의 영향을 충분히 고려한 후에
선택되어야 한다.