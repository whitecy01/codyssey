# The OAuth 2.0 Authorization Framework
인터넷 표준을 제정 / 관리하는 국제 표준화 기구                                                                  편집자는 D.Hardt
RFC 문서 번호 6749                                                                                     소속기관: 마이크로소프트
이 문서는 RFC 5849를 폐기하고 대체함 즉, 6749가 최신 표준이고 5849는 더 이상 사용 권장되지 않음                        문서발표일 2012년 10월
인터넷 공식 표준으로 채택되는 과정에 있는 문서
RFC 시리즈 전체에 부여된 국제 표준 연속간행물번호

### 초록 (Abstract)
OAuth 2.0 권한 부여 프레임워크를 사용하면 타사 애플리케이션이 HTTP 서비스에 대한 제한된 액세스 권한을 얻을 수 있습니다. 이는 리소스 소유자와 HTTP 서비스 간의 승인 상호 작용을 조정하여 리소스 소유자를 대신해 액세스 권한을 얻거나, 타사 애플리케이션이 직접 액세스 권한을 얻도록 허용하는 방식으로 이루어질 수 있습니다. 이 사양은 RFC 5849에 설명된 OAuth 1.0 프로토콜을 대체하고 더 이상 사용하지 않도록 합니다.

### 이 문서의 상태(Status of This Memo)

이 문서는 인터넷 표준 트랙 문서입니다.

이 문서는 인터넷 엔지니어링 태스크 포스(IETF)의 산물이며, IETF 커뮤니티의 합의를 반영합니다. 공개 검토를 거쳐 인터넷 엔지니어링 운영 그룹(IESG)의 승인을 받아 발행되었습니다. 인터넷 표준에 대한 자세한 정보는 RFC 5741의 2절에서 확인할 수 있습니다.

이 문서의 현재 상태, 오류 수정 사항 및 의견 제공 방법에 대한 정보는 http://www.rfc-editor.org/info/rfc6749에서 확인할 수 있습니다.

### 저작권 고지(Copyright Notice)
저작권(c) 2012 IETF Trust 및 문서 작성자로 명시된 개인. 모든 권리 보유.

이 문서는 BCP 78 및 이 문서 발행일 현재 유효한 IETF 신탁의 IETF 문서 관련 법적 조항(http://trustee.ietf.org/license-info)의 적용을 받습니다. 이 문서와 관련하여 귀하의 권리와 제한 사항이 명시되어 있으므로 해당 문서를 주의 깊게 검토하십시오. 이 문서에서 추출된 코드 구성 요소에는 신탁 법적 조항 4.e항에 설명된 간소화된 BSD 라이선스 텍스트가 포함되어야 하며, 간소화된 BSD 라이선스에 명시된 바와 같이 어떠한 보증도 없이 제공됩니다.

## 목차
1. [소개](#1-소개)
    - 1.1. [역할](#11-역할)
    - 1.2. [프르토콜 흐름](#12-프로토콜-흐름)
    - 1.3. [권한 부여 방식](#13-인가-승인) 
      - 1.3.1. [인가 코드](#131-인가-코드)
      - 1.3.2. [암시적 권한 부여 방식](#132-암시적-권한-부여-방식) 
      - 1.3.3. [리소스 소유자 비밀번호 자격 증명 방식](#133-리소스-소유자-비밀번호-자격-증명)
      - 1.3.4. [클라이언트 자격 증명](#134-클라이언트-자격-증명)
    - 1.4. [Access Token](#14-access-token) 
    - 1.5. [Refresh Token](#15-refresh-token)
    - 1.6. [TLS 버전](#16-tls-버전)
    - 1.7. [HTTP 리디렉션](#17-http-리디렉션)
    - 1.8. [상호 운용성](#18-상호-운용성)
    - 1.9. [표기 규칙](#19-표기-규칙)
2. [클라이언트 등록](#2-클라이언트-등록)
    - 2.1. [클라이언트 유형](#21-클라이언트-유형)
    - 2.2. [클라이언트 식별자](#22-클라이언트-식별자)
    - 2.3. [클라이언트 인증](#23-클라이언트-인증)
      - 2.3.1. [클라이언트 비밀번호](#231-클라이언트-비밀번호)
      - 2.3.2. [기타 인증 방식](#232-기타-인증-방법)
    - 2.4. [미등록 클라이언트](#24-미등록-클라이언트)
3. [프로토콜 엔드포인트](#3-프로토콜-엔드포인트)
    - 3.1. [인가 엔드포인트](#31-인가-엔드포인트)
      - 3.1.1. [응답 유형](#311-응답-유형)
      - 3.1.2. [리다이렉션 엔드포인트](#312-리다이렉션-엔드포인트) 
        - 3.1.2.1. [엔드포인트 요청 기밀성 - 추가](#3121-엔드포인트-요청-기밀성)
        - 3.1.2.2. [등록 요구 사항 - 추가](#3122-등록-요구-사항)
        - 3.1.2.3. [동적 구성 - 추가](#3123-동적-구성)
        - 3.1.2.4. [유효하지 않은 엔드포인트 - 추가](#3124-유효하지-않은-엔드포인트)
        - 3.1.2.5. [엔드포인트 콘텐츠 - 추가](#3125-엔드포인트-콘텐츠)
    - 3.2. [토큰 엔드포인트](#32-토큰-엔드포인트)
      - 3.2.1. [클라이언트 인증](#321-클라이언트-인증)
    - 3.3. [액세스 토큰 범위](#33-액세스-토큰-범위)
4. [권한 획득](#4-권한-획득)
    - 4.1. [인가 코드 방식](#41-인가-코드-방식)
      - 4.1.1. [인가 요청](#411-인가-요청) 
      - 4.1.2. [인가 응답](#412-인가-응답)
        - 4.1.2.1 [오류 응답](#4121-오류-응답)
      - 4.1.3. [액세스 토큰 요청](#413-액세스-토큰-요청) 
      - 4.1.4. [액세스 토큰 응답](#414-액세스-토큰-응답) 
    - 4.2. [암묵적 방식](#42-암묵적-방식)
      - 4.2.1. [인가 요청](#421-인가-요청) 
      - 4.2.2. [액세스 토큰 응답](#422-액세스-토큰-응답)
        - 4.2.2.1 [오류 응답](#4221-오류-응답)
    - 4.3. [리소스 소유자 비밀번호 방식](#43-리소스-소유자-비밀번호-자격-증명-방식) 
      - 4.3.1. [인가 요청 및 응답](#431-인가-요청-및-응답) 
      - 4.3.2. [액세스 토큰 요청](#432-액세스-토큰-요청) 
      - 4.3.3. [액세스 토큰 응답](#433-액세스-토큰-응답) 
    - 4.4. [클라이언트 자격 증명 방식](#44-클라이언트-자격-증명-방식)
      - 4.4.1. [인가 요청 및 응답](#441-인가-요청-및-응답)
      - 4.4.2. [액세스 토큰 요청](#442-액세스-토큰-요청)
      - 4.4.3. [액세스 토큰 응답](#443-액세스-토큰-응답)
    - 4.5. [확장 승인](#45-확장-승인)
5. [액세스 토큰 발급](#5-액세스-토큰-발급) 
    - 5.1. [성공 응답](#51-성공-응답)
    - 5.2. [오류 응답](#52-오류-응답) 
6. [액세스 토큰 갱신](#6-액세스-토큰-갱신) 
7. [보호된 리소스 접근](#7-보호된-리소스-접근) 
    - 7.1. [액세스 토큰 유형](#71-액세스-토큰-유형) 
    - 7.2. [오류 응답](#72-오류-응답)
8. [확장성](#8-확장성)
    - 8.1. [액세스 토큰 유형 정의](#81-액세스-토큰-유형-정의)
    - 8.2. [새로운 엔드포인트 매개변수 정의](#82-새로운-엔드포인트-매개변수-정의)
    - 8.3. [새로운 인가 그랜트 유형 정의](#83-새로운-인가-그랜트-유형-정의) 
    - 8.4. [새로운 인가 엔드포인트 응답 유형 정의](#84-새로운-인가-엔드포인트-응답-유형-정의)
    - 8.5. [추가 오류 코드 정의](#85-추가-오류-코드-정의)
9. [네이티브 애플리케이션](#9-네이티브-애플리케이션)
10. [보안 고려 사항](#10-보안-고려-사항)
    - 10.1. [클라이언트 인증](#101-클라이언트-인증)
    - 10.2. [클라이언트 사칭](#102-클라이언트-사칭)
    - 10.3. [액세스 토큰](#103-액세스-토큰)
    - 10.4. [리프레시 토큰](#104-리프레시-토큰)
    - 10.5. [인가 코드](#105-인가-코드) 
    - 10.6. [인가 코드 리다이렉션 URI 조작](#106-인가-코드-리다이렉션-uri-조작)
    - 10.7. [리소스 소유자 비밀번호 자격 증명](#107-리소스-소유자-비밀번호-자격-증명)
    - 10.8. [요청 기밀성](#108-요청-기밀성)
    - 10.9. [엔드포인트 진위 보장](#109-엔드포인트-진위-보장)
    - 10.10. [자격 증명 추측 공격](#1010-자격-증명-추측-공격)
    - 10.11. [피싱 공격](#1011-피싱-공격)
    - 10.12. [교차 사이트 요청 위조](#1012-교차-사이트-요청-위조)
    - 10.13. [클릭재킹](#1013-클릭재킹)
    - 10.14. [코드 주입 및 입력값 검증](#1014-코드-주입-및-입력-검증) 
    - 10.15. [오픈 리다이렉터](#1015-오픈-리다이렉터) 
    - 10.16. [암묵적 흐름에서 액세스 토큰을 사용한 리소스 소유자 가장](#1016-암묵적-흐름에서-액세스-토큰을-사용한-리소스-소유자-가장)
11. [IANA 고려 사항](#11-iana-고려-사항)
    - 11.1. [액세스 토큰 유형 레지스트리](#111-액세스-토큰-유형-레지스트리)
      - 11.1.1. [등록 템플릿](#1111-등록-템플릿)
    - 11.2. [Oauth 매개변수 레지스트리](#112-oauth-매개변수-레지스트리)
      - 11.2.1. [등록 템플릿](#1121-등록-템플릿)
      - 11.2.2. [초기 레지스트리 내용](#1122-초기-레지스트리-내용)
    - 11.3. [OAuth 인가 엔드포인트 응답 유형 레지스트리](#113-oauth-인가-엔드포인트-응답-유형-레지스트리)
      - 11.3.1. [등록 템플릿](#1131-등록-템플릿)
      - 11.3.2. [초기 레지스트리 내용](#1132-초기-레지스트리-내용) 
    - 11.4. [OAuth 확장 오류 레지스트리](#114-oauth-확장-오류-레지스트리)
      - 11.4.1. [등록 템플릿](#1141-등록-템플릿)
12. [참고 문헌](#12-참고-문헌)
    - 12.1. [규범적 참고 문헌](#121-규범적-참고-문헌)
    - 12.2. [정보 제공용 참고 문헌](#122-정보-제공공-참고-문헌)
13. [부록 A. 확장된 백커스–나우르 형식(ABNF) 문법](#부록-a-확장된-백커스나우르-형식abnf-문법)
    - [A.1.  "client_id" 문법](#a1-client_id-문법) 
    - [A.2.  "client_secret" 문법](#a2-client_secret-문법) 
    - [A.3.  "response_type" 문법](#a3-response_type-문법) 
    - [A.4.  "scope" 문법](#a4-scope-문법)
    - [A.5.  "state" 문법](#a5-state-문법)
    - [A.6.  "redirect_uri" 문법](#a6-redirect_uri-문법) 
    - [A.7.  "error" 문법](#a8-error_description-문법)
    - [A.8.  "error_description" 문법](#a8-error_description-문법)
    - [A.9.  "error_uri" 문법](#a9-error_uri-문법)
    - [A.10. "grant_type" 문법](#a10-grant_type-문법) 
    - [A.11. "code" 문법](#a11-code-문법) 
    - [A.12. "access_token" 문법](#a12-access_token-문법) 
    - [A.13. "token_type" 문법](#a13-token_type-문법)
    - [A.14. "expires_in" 문법](#a14-expires_in-문법)
    - [A.15. "username" 문법](#a15-username-문법)
    - [A.16. "password" 문법](#a16-password-문법)
    - [A.17. "refresh_token" 문법](#a17-refresh_token-문법)
    - [A.18. Endpoint Parameter 문법](#a18-엔드포인트-매개변수-문법)
14. [부록 B. application/x-www-form-urlencoded 미디어 타입 사용](#부록-b-applicationx-www-form-urlencoded-미디어-타입의-사용) 
15. [부록 C. 감사의 말](#부록-c-감사의-말)

## 1. 소개
기존의 클라이언트-서버 인증 모델에서 클라이언트는 리소스 소유자의 자격 증명을 사용하여 서버에 인증함으로써 접근이 제한된 리소스(보호된 리소스)에 대한 접근을 요청합니다. 제3자 애플리케이션이 제한된 리소스에 접근할 수 있도록 하려면 리소스 소유자는 자신의 자격 증명을 제3자와 공유해야 합니다. 하지만 이로 인해 다음과 같은 몇 가지 문제점과 한계가 발생합니다.

- 타사 애플리케이션은 리소스 소유자의 자격 증명(일반적으로 평문으로 저장된 암호)을 향후 사용을 위해 저장해야 합니다.
- 서버는 암호에 내재된 보안 취약점에도 불구하고 암호 인증을 지원해야 합니다.
- 타사 애플리케이션은 리소스 소유자의 보호된 리소스에 대해 지나치게 광범위한 접근 권한을 획득하여, 리소스 소유자가 접근 기간이나 접근 범위를 리소스의 일부로 제한할 수 없게 됩니다.
- 리소스 소유자는 개별 타사의 접근 권한을 취소할 수 없으며, 모든 타사의 접근 권한을 취소하지 않고는 해당 타사의 접근 권한을 취소할 수 없습니다. 따라서 타사의 암호를 변경해야 합니다.
- 타사 애플리케이션이 손상되면 최종 사용자의 암호와 해당 암호로 보호되는 모든 데이터가 손상됩니다.

OAuth는 권한 부여 계층을 도입하고 클라이언트와 리소스 소유자의 역할을 분리함으로써 이러한 문제를 해결합니다. OAuth에서 클라이언트는 리소스 소유자가 관리하고 리소스 서버에서 호스팅하는 리소스에 대한 접근을 요청하고, 리소스 소유자와는 다른 자격 증명 세트를 발급받습니다.

클라이언트는 보호된 리소스에 접근할 때 리소스 소유자의 자격 증명을 사용하는 대신, 특정 범위, 유효 기간 및 기타 접근 속성을 나타내는 문자열인 액세스 토큰을 획득합니다. 액세스 토큰은 리소스 소유자의 승인을 받아 권한 부여 서버에서 제3자 클라이언트에게 발급됩니다. 클라이언트는 이 액세스 토큰을 사용하여 리소스 서버에서 호스팅하는 보호된 리소스에 접근합니다.

예를 들어, 최종 사용자(리소스 소유자)는 사진 공유 서비스(리소스 서버)에 저장된 보호된 사진에 대한 접근 권한을 인쇄 서비스(클라이언트)에 부여할 수 있습니다. 이때 사용자 이름과 비밀번호를 인쇄 서비스와 공유할 필요는 없습니다. 대신, 사진 공유 서비스에서 신뢰하는 서버(권한 부여 서버)에 직접 인증하여 인쇄 서비스에 대한 위임 전용 자격 증명(액세스 토큰)을 발급받습니다.

이 사양은 HTTP([RFC2616])와 함께 사용하도록 설계되었습니다.
HTTP 이외의 프로토콜을 통한 OAuth 사용은 이 사양의 범위를 벗어납니다.

정보 문서로 발표된 OAuth 1.0 프로토콜([RFC5849])은 소규모 임시 커뮤니티의 노력으로 탄생했습니다. 이 표준 트랙 사양은 OAuth 1.0 배포 경험과 더 넓은 IETF 커뮤니티에서 수집한 추가 사용 사례 및 확장성 요구 사항을 기반으로 합니다. OAuth 2.0 프로토콜은 OAuth 1.0과 하위 호환되지 않습니다. 두 버전은 네트워크에서 공존할 수 있으며, 구현체는 둘 다 지원하도록 선택할 수 있습니다. 그러나 이 사양의 의도는 새로운 구현체가 이 문서에 명시된 대로 OAuth 2.0을 지원하고 OAuth 1.0은 기존 배포를 지원하는 데에만 사용하도록 하는 것입니다. OAuth 2.0 프로토콜은 OAuth 1.0 프로토콜과 구현 세부 사항을 거의 공유하지 않습니다. OAuth 1.0에 익숙한 구현체는 이 문서의 구조와 세부 사항에 대한 어떠한 가정도 없이 접근해야 합니다.

### 1.1 역할
OAuth는 다음과 같은 네 가지 역할을 정의합니다.

1. 리소스 소유자
- 보호된 리소스에 대한 접근 권한을 부여할 수 있는 주체. 리소스 소유자가 사람인 경우, 최종 사용자라고 합니다.

2. 리소스 서버
- 보호된 리소스를 호스팅하고, 액세스 토큰을 사용하여 보호된 리소스 요청을 수락하고 응답할 수 있는 서버.

3. 클라이언트 
- 리소스 소유자를 대신하여 권한을 부여받아 보호된 리소스에 대한 요청을 하는 애플리케이션.
"클라이언트"라는 용어는 특정 구현 특성(예: 서버, 데스크톱 또는 기타 장치에서 실행되는지 여부)을 의미하지 않습니다.

4. 권한 부여 서버
- 리소스 소유자를 성공적으로 인증하고 권한을 획득한 후 클라이언트에게 액세스 토큰을 발급하는 서버.

권한 부여 서버와 리소스 서버 간의 상호 작용은 이 사양의 범위를 벗어납니다. 권한 부여 서버는 리소스 서버와 동일한 서버일 수도 있고, 별도의 개체일 수도 있습니다. 단일 권한 부여 서버는 여러 리소스 서버에서 허용되는 액세스 토큰을 발급할 수 있습니다.

### 1.2 프로토콜 흐름

```
     +--------+                                  +---------------+
     |        |---------(A)- 인가 요청------------>|   리소스 소유자  |
     |        |                                  |               |
     |        |<-(B)-- 인가 승인 정보(권한 부여 결과)---|               |
     |        |                                  +---------------+
     |        |
     |        |                                  +--------------+
     |        |--(C)-- 인가 승인 정보(권한 부여 결과)-->|    인가 서버    |
     | 클라이언트|                                  |               |
     |        |<-(D)----- Access Token ----------|               |
     |        |                                  +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    리소스 서버   |
     |        |                               |               |
     |        |<-(F)-------보호된 리소스---------|               |
     +--------+                               +---------------+

                     그림 1: 추상적인 프로토콜 흐름
```
그림 1에 나타낸 추상적인 OAuth 2.0 흐름은 네 가지 역할 간의 상호 작용을 설명하며 다음과 같은 단계를 포함합니다.

(A) 클라이언트는 리소스 소유자에게 권한 부여를 요청합니다. 권한 부여 요청은 리소스 소유자에게 직접 (그림과 같이) 또는 (가급적이면) 권한 부여 서버를 통해 간접적으로 수행할 수 있습니다.
(B) 클라이언트는 권한 부여 부여(authorization grant)를 수신합니다. 이는 리소스 소유자의 권한을 나타내는 자격 증명으로, 이 명세에 정의된 네 가지 부여 유형 중 하나 또는 확장 부여 유형을 사용하여 표현됩니다. 권한 부여 부여 유형은 클라이언트가 권한을 요청하는 데 사용한 방법과 권한 부여 서버에서 지원하는 유형에 따라 달라집니다.
(C) 클라이언트는 권한 부여 서버에 인증하고 권한 부여 부여를 제시하여 액세스 토큰을 요청합니다.
(D) 권한 부여 서버는 클라이언트를 인증하고 권한 부여를 검증하며, 유효한 경우 액세스 토큰을 발급합니다.
(E) 클라이언트는 리소스 서버에 보호된 리소스를 요청하고 액세스 토큰을 제시하여 인증합니다.
(F) 리소스 서버는 액세스 토큰을 검증하고, 유효한 경우 요청을 처리합니다.

클라이언트가 리소스 소유자로부터 권한 부여를 얻는 데 선호되는 방법(단계 (A) 및 (B)에 설명됨)은 권한 부여 서버를 중개자로 사용하는 것이며 이는 섹션 4.1의 그림 3에 설명되어 있습니다.

### 1.3 권한 부여 방식
권한 부여는 클라이언트가 액세스 토큰을 얻기 위해 사용하는 리소스 소유자의 권한(보호된 리소스에 접근할 수 있는 권한)을 나타내는 자격 증명입니다. 이 사양에서는 권한 부여 코드, 암시적, 리소스 소유자 암호 자격 증명 및 클라이언트 자격 증명의 네 가지 부여 유형과 추가 유형을 정의할 수 있는 확장 메커니즘을 정의합니다.

#### 1.3.1 인가 코드
Authorization Code 방식에서는, 클라이언트와 사용자 사이에서 인가 서버가 중간 역할을 한다. 클라이언트는 사용자에게 직접 “권한을 주세요”라고 요청하지 않고, 사용자를 인가 서버로 보내어(브라우저 같은 사용자 에이전트를 통해) 인가 서버가 대신 처리하도록 한다. 인가 서버는 사용자를 인증(로그인)하고 클라이언트가 요청한 권한에 대해 사용자의 동의를 받은 뒤 사용자를 다시 클라이언트로 돌려보내면서 ‘인가 코드(authorization code)’를 전달한다. 이 과정에서 사용자는 오직 인가 서버에만 로그인하기 때문에, 사용자의 아이디와 비밀번호는 클라이언트에 절대 전달되지 않는다.

인증 코드는 클라이언트를 인증하는 기능과 리소스 소유자의 사용자 에이전트를 거치지 않고 액세스 토큰을 클라이언트에 직접 전송하여 리소스 소유자를 포함한 다른 사람에게 노출될 가능성을 줄이는 기능 등 몇 가지 중요한 보안 이점을 제공합니다.

#### 1.3.2 암시적 권한 부여 방식
Implicit Grant(암시적 권한 부여 방식)은 JavaScript와 같은 스크립트 언어를 사용해 브라우저에서 구현된 클라이언트에 최적화된 간소화된 Authorization Code 흐름입니다. Implicit 흐름에서는 클라이언트에게 인가 코드(authorization code)를 발급하는 대신 리소스 소유자의 승인 결과로 액세스 토큰을 직접 발급합니다. 이 방식은 인가 코드와 같은 중간 자격 증명이 발급되지 않고 (그리고 이후에 액세스 토큰을 얻는 데 사용되지도 않기 때문에) grant 타입이 ‘implicit(암시적)’이라고 불린다.


Implicit Grant 흐름에서 액세스 토큰을 발급할 때 인가 서버는 클라이언트를 인증하지 않습니다. 일부 경우에는 액세스 토큰을 클라이언트에 전달하기 위해 사용되는 리다이렉션 URI를 통해 클라이언트의 식별을 확인할 수도 있다. 하지만 액세스 토큰은 리소스 소유자 또는 리소스 소유자의 사용자 에이전트에 접근할 수 있는 다른 애플리케이션에 노출될 수 있다.

Implicit Grant는 액세스 토큰을 얻기 위해 필요한 통신 왕복 횟수를 줄이기 때문에 브라우저 내에서 동작하는 애플리케이션과 같은 일부 클라이언트에서는 응답성과 효율성을 향상시킨다. 그러나 이러한 편의성은 특히 Authorization Code Grant를 사용할 수 있는 경우에는 섹션 10.3과 10.16에서 설명된 것과 같은 Implicit Grant 사용에 따른 보안상의 영향을 충분히 고려한 후에 선택되어야 한다.

#### 1.3.3 리소스 소유자 비밀번호 자격 증명
리소스 소유자의 비밀번호 자격 증명(즉, 사용자 이름과 비밀번호)은 액세스 토큰을 얻기 위한 인가 승인 정보(authorization grant)로서 직접 사용될 수 있다. 이 자격 증명은 리소스 소유자와 클라이언트 사이에 높은 수준의 신뢰가 존재하는 경우에만 사용되어야 하며 (예: 클라이언트가 디바이스 운영체제의 일부이거나, 매우 높은 권한을 가진 애플리케이션인 경우), 그리고 인가 코드와 같은 다른 인가 승인 방식이 사용할 수 없는 경우에만 사용되어야 한다.

이 인가 승인 방식은 클라이언트가 리소스 소유자의 자격 증명에 직접 접근해야 함에도 불구하고 리소스 소유자의 자격 증명은 단 한 번의 요청에만 사용되며 그 이후에는 액세스 토큰으로 교환된다. 이 방식은 자격 증명을 장기적으로 사용 가능한 액세스 토큰이나 리프레시 토큰으로 교환함으로써 클라이언트가 리소스 소유자의 자격 증명을 향후 사용을 위해 저장할 필요를 없앨 수 있다.

#### 1.3.4 클라이언트 자격 증명
클라이언트 자격 증명(또는 다른 형태의 클라이언트 인증 수단)은 인가 범위가 클라이언트의 관리 하에 있는 보호된 리소스로 제한되거나 또는 사전에 인가 서버와 협의된 보호된 리소스에 한정되는 경우 인가 승인 정보(authorization grant)로 사용될 수 있다. 클라이언트 자격 증명은 일반적으로 클라이언트가 자기 자신을 대표하여 동작하는 경우(즉, 클라이언트가 리소스 소유자이기도 한 경우) 또는 인가 서버와 미리 합의된 인가를 기반으로 보호된 리소스에 접근을 요청하는 경우에 인가 승인 정보로 사용된다.

### 1.4 Access Token
액세스 토큰(access token)은 보호된 리소스에 접근하기 위해 사용되는 자격 증명이다. 액세스 토큰은 클라이언트에게 발급된 인가(authorization)를 나타내는 문자열이다. 이 문자열은 보통 클라이언트가 해석할 수 없는 불투명한 값이다. 토큰은 리소스 소유자가 부여한 특정 접근 범위(scope)와 접근 기간(duration)을 나타내며,
이 접근 권한은 리소스 서버와 인가 서버에 의해 강제된다.

이 토큰은 인가 정보를 조회하기 위해 사용되는 식별자(identifier)를 나타낼 수도 있고, 또는 인가 정보를 자체적으로 포함하고 검증 가능한 형태일 수도 있다(즉, 데이터와 서명으로 구성된 토큰 문자열일 수 있다). 이 명세의 범위를 벗어나는 추가적인 인증 자격 증명이 클라이언트가 토큰을 사용하기 위해 요구될 수도 있다.

액세스 토큰은 사용자 이름과 비밀번호와 같은 다양한 인가 수단을 하나의 토큰으로 대체하는 추상화 계층을 제공하며, 이 토큰은 리소스 서버가 이해할 수 있는 단일한 형태로 사용된다. 이러한 추상화는 토큰을 발급받는 데 사용된 인가 승인 정보보다 더 제한적인 권한을 가진 액세스 토큰을 발급할 수 있게 해주며 리소스 서버가 다양한 인증 방식들을 모두 이해할 필요를 없애준다.

액세스 토큰은 리소스 서버의 보안 요구 사항에 따라 서로 다른 형식, 구조, 그리고 사용 방식 (예: 암호학적 속성)을 가질 수 있다. 액세스 토큰의 속성과 보호된 리소스에 접근하는 방법에 대한 상세 내용은 이 명세의 범위를 벗어나며 [RFC6750]과 같은 관련 명세에서 정의된다.

### 1.5 Refresh Token
리프레시 토큰은 액세스 토큰을 얻기 위해 사용되는 자격 증명이다. 리프레시 토큰은 인가 서버가 클라이언트에게 발급하며 현재의 액세스 토큰이 유효하지 않게 되거나 만료되었을 때 또는 동일하거나 더 제한된 범위(scope)를 가진 추가 액세스 토큰을 얻기 위해 사용된다 (액세스 토큰은 리소스 소유자가 허락한 권한보다 더 짧은 수명이나 더 적은 권한을 가질 수 있다). 리프레시 토큰을 발급할지는 인가 서버의 재량에 따라 선택 사항이다. 인가 서버가 리프레시 토큰을 발급하는 경우, 이는 액세스 토큰을 발급할 때 함께 포함된다(즉, 그림 1의 단계 (D)).

리프레시 토큰은 리소스 소유자가 클라이언트에게 부여한 인가를 나타내는 문자열이다. 이 문자열은 보통 클라이언트가 해석할 수 없는 불투명한 값이다. 이 토큰은 인가 정보를 조회하기 위해 사용되는 식별자(identifier)를 나타낸다. 액세스 토큰과 달리 리프레시 토큰은 인가 서버에서만 사용하도록 의도된 것이며 리소스 서버에는 절대 전달되지 않는다.


```
  +--------+                                           +---------------+
  |        |--(A)------- 인가 승인 정보 ----------------->|               |
  |        |                                           |               |
  |        |<-(B)----------- Access Token -------------|               |
  |        |               & Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token ----------->|               |
  |        |                                           |               |
  |        |<-(H)----------- Access Token -------------|               |
  +--------+           & Optional Refresh Token        +---------------+

               Figure 2:  만료된 액세스 토큰 갱신 흐름
```

그림 2에 나타난 흐름은 다음 단계를 포함한다.

(A) 클라이언트는 인가 서버에 인증하고 인가 승인 정보(authorization grant)를 제시하여 액세스 토큰을 요청한다.

(B) 인가 서버는 클라이언트를 인증하고 인가 승인 정보를 검증하며 유효한 경우 액세스 토큰과 리프레시 토큰을 발급한다.

(C) 클라이언트는 액세스 토큰을 제시하여 리소스 서버에 보호된 리소스를 요청한다.

(D) 리소스 서버는 액세스 토큰을 검증하고 유효한 경우 요청을 처리한다.

(E) 액세스 토큰이 만료될 때까지 (C)와 (D) 단계가 반복된다. 클라이언트가 액세스 토큰의 만료를 알고 있다면 (G) 단계로 바로 이동하고 그렇지 않으면 다시 보호된 리소스를 요청한다.

(F) 액세스 토큰이 유효하지 않으므로 리소스 서버는 유효하지 않은 토큰 오류를 반환한다.

(G) 클라이언트는 인가 서버에 인증하고 리프레시 토큰을 제시하여 새로운 액세스 토큰을 요청한다. 클라이언트 인증 요구 사항은 클라이언트 유형과 인가 서버 정책에 따라 달라진다.

(H) 인가 서버는 클라이언트를 인증하고 리프레시 토큰을 검증하며 유효한 경우 새로운 액세스 토큰을 발급하고 (선택적으로) 새로운 리프레시 토큰도 함께 발급한다.

단계 (C), (D), (E), (F)는 7절에서 설명된 바와 같이 이 명세의 범위를 벗어난다.

### 1.6 TLS 버전
이 명세에서 전송 계층 보안(Transport Layer Security, TLS)이 사용되는 경우, 적절한 TLS 버전(또는 버전들)은 시간이 지나면서 달라질 수 있으며, 이는 널리 배포된 정도와 알려진 보안 취약점에 따라 결정된다. 이 문서가 작성된 시점에서는, TLS 버전 1.2 [RFC5246]가 가장 최신 버전이지만, 배포된 범위가 매우 제한적이며 구현 환경에서 즉시 사용하기 어려울 수도 있다. TLS 버전 1.0 [RFC2246]은 가장 널리 배포된 버전이며, 가장 폭넓은 상호 운용성을 제공한다.

구현체는 또한, 자신들의 보안 요구 사항을 충족하는 경우에 한해 추가적인 전송 계층 보안 메커니즘을 지원할 수도 있다.

### 1.7 HTTP 리디렉션
이 명세는 HTTP 리다이렉션을 광범위하게 사용하며 이 과정에서 클라이언트 또는 인가 서버가 리소스 소유자의 사용자 에이전트(user-agent)를 다른 목적지로 이동시키도록 지시한다. 이 명세에 포함된 예제들은 HTTP 302 상태 코드를 사용하는 경우를 보여주지만, 사용자 에이전트를 통해 이러한 리다이렉션을 수행할 수 있는 다른 모든 방법 또한 허용되며 이는 구현 세부 사항(implementation detail)으로 간주된다.

### 1.8 상호 운용성
OAuth 2.0은 명확하게 정의된 보안 특성을 갖춘 풍부한 인가 프레임워크를 제공한다. 그러나 이 프레임워크는 구성 요소가 많고 선택 사항이 많은 매우 확장 가능한 구조이기 때문에 이 명세만으로는 서로 호환되지 않는 다양한 구현체들이 생길 가능성이 크다.

또한 이 명세는 몇 가지 필수 구성 요소들을 부분적으로만 정의하거나 아예 정의하지 않고 남겨두고 있다(예: 클라이언트 등록, 인가 서버의 기능, 엔드포인트 탐색 등). 이러한 구성 요소들이 없으면 클라이언트는 특정 인가 서버 및 리소스 서버와 상호 운용하기 위해 수동으로 개별 설정을 해야만 한다.

이 프레임워크는 처음부터 향후 작업을 통해 웹 전체 규모에서의 완전한 상호 운용성을 달성하기 위해 필요한 규범적인 프로파일과 확장들이 정의될 것이라는 명확한 기대를 가지고 설계되었다.

### 1.9 표기 규칙
이 명세에서 사용되는 “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, “OPTIONAL”과 같은 핵심 단어들은 [RFC2119]에 설명된 의미로 해석되어야 한다.

이 명세는 [RFC5234]에 정의된 확장 백우스-나우르 형식(Augmented Backus-Naur Form, ABNF)표기법을 사용한다. 또한, “Uniform Resource Identifier (URI): Generic Syntax” [RFC3986]에 정의된 URI-reference 규칙을 포함한다.

일부 보안 관련 용어들은 [RFC4949]에 정의된 의미로 이해되어야 한다. 이러한 용어에는 “attack(공격)”, “authentication(인증)”, “authorization(인가)”, “certificate(인증서)”, “confidentiality(기밀성)”, “credential(자격 증명)”, “encryption(암호화)”, “identity(신원)”, “sign(서명하다)”, “signature(서명)”, “trust(신뢰)”, “validate(유효성 검사)”, “verify(검증)” 등이 포함되며, 이에 한정되지는 않는다.

별도로 명시되지 않는 한, 모든 프로토콜 파라미터 이름과 값은 대소문자를 구분한다.

## 2. 클라이언트 등록
프로토콜을 시작하기 전에, 클라이언트는 인가 서버에 등록(register)해야 한다. 클라이언트가 인가 서버에 등록하는 방법은 이 명세의 범위를 벗어나지만, 일반적으로는 HTML 등록 양식을 통한 최종 사용자와의 상호작용을 포함한다.

클라이언트 등록은 반드시 클라이언트와 인가 서버 간의 직접적인 상호작용을 요구하지는 않는다. 인가 서버가 이를 지원하는 경우, 등록은 신뢰를 설정하고 필요한 클라이언트 속성들을 얻기 위한 다른 방법들에 의존할 수 있다(예: 리다이렉션 URI, 클라이언트 유형). 예를 들어, 등록은 자체 발급된(assertion) 또는 제3자가 발급한 assertion을 사용하여 이루어질 수도 있고, 또는 인가 서버가 신뢰된 채널을 통해 클라이언트를 탐색(discovery)함으로써 수행될 수도 있다.

클라이언트를 등록할 때,클라이언트 개발자는 반드시 다음을 수행해야 한다(SHALL):
- 섹션 2.1에 설명된 대로 클라이언트 유형(client type)을 지정해야 한다.
- 섹션 3.1.2에 설명된 대로 클라이언트 리다이렉션 URI를 제공해야 한다.
- 그리고 인가 서버가 요구하는 기타 모든 정보를 포함해야 한다(예: 애플리케이션 이름, 웹사이트, 설명, 로고 이미지, 법적 약관에 대한 동의).

### 2.1 클라이언트 유형
OAuth는 인가 서버와 안전하게 인증할 수 있는 능력, 즉 클라이언트 자격 증명의 기밀성을 유지할 수 있는 능력을 기준으로 두 가지 클라이언트 유형을 정의한다.

- 기밀 클라이언트(confidential)
기밀 클라이언트는 자신의 자격 증명의 기밀성을 유지할 수 있는 클라이언트이다(예: 클라이언트 자격 증명에 대한 접근이 제한된 보안 서버에서 구현된 클라이언트), 또는 다른 수단을 사용하여 안전한 클라이언트 인증이 가능한 경우를 말한다.

- 공개 클라이언트(public)
공개 클라이언트는 자신의 자격 증명의 기밀성을 유지할 수 없는 클라이언트이다(예: 리소스 소유자가 사용하는 장치에서 실행되는 클라이언트로, 설치형 네이티브 애플리케이션이나 웹 브라우저 기반 애플리케이션 등), 그리고 어떠한 다른 방법으로도 안전한 클라이언트 인증이 불가능한 경우를 말한다.

클라이언트 유형의 지정은 인가 서버가 정의한 안전한 인증 기준과 클라이언트 자격 증명이 노출될 수 있는 허용 수준을 기준으로 한다. 인가 서버는 클라이언트 유형에 대해 임의로 가정해서는 안 된다(SHOULD NOT).


클라이언트는 각각 다른 클라이언트 유형과 보안 환경을 가진 여러 구성 요소로 분산되어 구현될 수도 있다 (예: 기밀 서버 기반 구성 요소와 공개 브라우저 기반 구성 요소를 모두 가진 분산 클라이언트).

인가 서버가 이러한 클라이언트를 지원하지 않거나 등록에 대한 지침을 제공하지 않는 경우, 클라이언트는 각 구성 요소를 별도의 클라이언트로 등록해야 한다(SHOULD).

이 명세는 다음과 같은 클라이언트 프로파일을 기준으로 설계되었다.
- 웹 애플리케이션(web application)
웹 애플리케이션은 웹 서버에서 실행되는 기밀 클라이언트이다. 리소스 소유자는 자신의 장치에 있는 사용자 에이전트에서 렌더링된 HTML 사용자 인터페이스를 통해 이 클라이언트에 접근한다. 클라이언트 자격 증명과 클라이언트에게 발급된 모든 액세스 토큰은 웹 서버에 저장되며, 리소스 소유자에게 노출되거나 접근 가능하지 않다.

- 사용자 에이전트 기반 애플리케이션(user-agent-based application)
사용자 에이전트 기반 애플리케이션은 웹 서버로부터 클라이언트 코드가 다운로드되어 리소스 소유자가 사용하는 장치의 사용자 에이전트(예: 웹 브라우저) 내에서 실행되는 공개 클라이언트이다. 프로토콜 데이터와 자격 증명은 리소스 소유자가 쉽게 접근할 수 있으며 (종종 눈에 보이기도 한다). 이러한 애플리케이션은 사용자 에이전트 내부에 존재하기 때문에, 인가를 요청할 때 사용자 에이전트의 기능을 자연스럽게 활용할 수 있다.

- native application (네이티브 애플리케이션)
네이티브 애플리케이션은 리소스 소유자가 사용하는 장치에 설치되어 실행되는 공개 클라이언트이다. 프로토콜 데이터와 자격 증명은 리소스 소유자가 접근할 수 있다. 애플리케이션에 포함된 어떠한 클라이언트 인증 자격 증명도 추출될 수 있다고 가정한다. 반면, 액세스 토큰이나 리프레시 토큰과 같이 동적으로 발급되는 자격 증명은 허용 가능한 수준의 보호를 받을 수 있다. 최소한, 이러한 자격 증명은 애플리케이션이 상호작용할 수 있는 악의적인 서버로부터는 보호된다. 일부 플랫폼에서는 같은 장치에 존재하는 다른 애플리케이션으로부터도 이 자격 증명이 보호될 수 있다.

### 2.2 클라이언트 식별자
인가 서버는 등록된 클라이언트에게 클라이언트 식별자(client identifier)를 발급한다. 이 클라이언트 식별자는 클라이언트가 제공한 등록 정보를 나타내는 고유한 문자열이다. 클라이언트 식별자는 비밀 값이 아니며, 리소스 소유자에게 노출된다. 따라서 클라이언트 식별자는 클라이언트 인증을 위해 단독으로 사용되어서는 안 된다(MUST NOT). 클라이언트 식별자는 해당 인가 서버에 대해서만 고유하다.

클라이언트 식별자 문자열의 크기(길이)는 이 명세에서 정의하지 않는다. 클라이언트는 식별자의 크기에 대해 임의로 가정해서는 안 된다. 인가 서버는 자신이 발급하는 모든 식별자의 크기를 문서로 명시하는 것이 바람직하다(SHOULD).

### 2.3 클라이언트 인증
클라이언트 유형이 기밀 클라이언트(confidential)인 경우, 클라이언트와 인가 서버는 인가 서버의 보안 요구 사항에 적합한 클라이언트 인증 방법을 설정한다. 인가 서버는 자신의 보안 요구 사항을 충족하는 어떠한 형태의 클라이언트 인증 방식도 받아들일 수 있다(MAY).

기밀 클라이언트는 일반적으로 인가 서버와 인증하기 위해 사용되는 클라이언트 자격 증명 집합을 발급받거나(또는 설정한다) (예: 비밀번호, 공개키/개인키 쌍).

인가 서버는 공개 클라이언트(public client)와도 클라이언트 인증 방법을 설정할 수 있다(MAY). 그러나 인가 서버는 클라이언트를 식별하기 위한 목적으로 공개 클라이언트의 인증에 의존해서는 안 된다(MUST NOT).

클라이언트는 각 요청마다 하나를 초과하는 인증 방법을 사용해서는 안 된다(MUST NOT).

### 2.3.1 클라이언트 비밀번호
클라이언트 비밀번호를 보유한 클라이언트는, [RFC2617]에 정의된 HTTP Basic 인증 방식을 사용하여 인가 서버에 인증할 수 있다(MAY). 이때 클라이언트 식별자는 부록 B에 따라 “application/x-www-form-urlencoded” 인코딩 알고리즘으로 인코딩되어 사용자 이름(username)으로 사용되며, 클라이언트 비밀번호는 같은 인코딩 알고리즘으로 인코딩되어 비밀번호(password)로 사용된다. 인가 서버는 클라이언트 비밀번호가 발급된 클라이언트를 인증하기 위해 HTTP Basic 인증 방식을 반드시 지원해야 한다(MUST).

예시 (표시를 위해 줄바꿈을 추가한 것임)
```
Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3
```
대안적으로, 인가 서버는 다음 파라미터를 사용하여 요청 본문(request-body)에 클라이언트 자격 증명을 포함하는 방식을 지원할 수도 있다(MAY).

- client_id
  - 필수(REQUIRED), 섹션 2.2에서 설명된 등록 과정 중 클라이언트에게 발급된 클라이언트 식별자
- client_secret
  - 필수(REQUIRED), 클라이언트 비밀 값, 클라이언트 비밀 값이 빈 문자열인 경우, 클라이언트는 이 파라미터를 생략할 수 있다(MAY)

이 두 파라미터를 사용하여 요청 본문에 클라이언트 자격 증명을 포함하는 방식은 권장되지 않는다(NOT RECOMMENDED). 이 방식은 HTTP Basic 인증 방식(또는 다른 비밀번호 기반 HTTP 인증 방식)을 직접 사용할 수 없는 클라이언트로 제한되어야 한다(SHOULD). 이 파라미터들은 요청 본문에서만 전송될 수 있으며, 요청 URI에는 포함되어서는 안 된다(MUST NOT).

예시: 액세스 토큰을 새로고침하기 위해 (Section 6) 아래와 같은 바디 파라미터를 사용하는 요청
```
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
&client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
```

1.6절에 명시한 것처럼, 인가 서버는 비밀번호 인증을 사용하는 요청에 대해 TLS 사용을 요구해야한다 (MUST).

해당 인증 방식은 비밀번호를 포함하기 때문에 인가 서버는 이러한 방식을 사용하는 엔드포인트를 무차별 공격 (bruteforce attack) 으로부터 보호해야한다(MUST).

### 2.3.2 기타 인증 방법
인가 서버는 자신의 보안 요구 사항에 부합하는 어떠한 적절한 HTTP 인증 방식도 지원할 수 있다(MAY). 다른 인증 방식을 사용하는 경우, 인가 서버는 클라이언트 식별자(등록 기록)와 인증 방식 사이의 매핑 관계를 반드시 정의해야 한다(MUST).

### 2.4 미등록 클라이언트
이 명세는 등록되지 않은 클라이언트의 사용을 배제하지는 않는다. 그러나 이러한 클라이언트의 사용은 이 명세의 범위를 벗어나며, 그 사용에 대해서는 추가적인 보안 분석과 상호 운용성에 미치는 영향에 대한 검토가 필요하다.

## 3. 프로토콜 엔드포인트
인가 과정은 두 개의 인가 서버 엔드포인트(HTTP 리소스)를 사용한다.

- Authorization endpoint(인가 엔드포인트) 클라이언트가 사용자 에이전트 리다이렉션을 통해 리소스 소유자로부터 인가를 얻기 위해 사용하는 엔드포인트
- Token endpoint(토큰 엔드포인트) 클라이언트가 인가 승인 정보(authorization grant)를 액세스 토큰으로 교환하기 위해 사용하는 엔드포인트이며 일반적으로 클라이언트 인증을 포함한다.

또한, 다음과 같은 하나의 클라이언트 엔드포인트가 있다.

- Redirection endpoint(리다이렉션 엔드포인트) 인가 서버가 리소스 소유자의 사용자 에이전트를 통해 인가 자격 증명을 포함한 응답을 클라이언트에게 반환하기 위해 사용하는 엔드포인트

모든 인가 승인 유형이 이 두 엔드포인트를 모두 사용하는 것은 아니다. 확장 인가 승인 유형(extension grant types)은 필요에 따라 추가적인 엔드포인트를 정의할 수도 있다(MAY).

### 3.1 인가 엔드포인트
인가 엔드포인트는 리소스 소유자와 상호작용하여 인가 승인 정보(authorization grant)를 얻기 위해 사용된다. 인가 서버는 반드시 먼저 리소스 소유자의 신원을 확인해야 한다(MUST). 인가 서버가 리소스 소유자를 인증하는 방식 (예: 사용자 이름과 비밀번호 로그인, 세션 쿠키 등)은 이 명세의 범위를 벗어난다.

클라이언트가 인가 엔드포인트의 위치를 얻는 방법 역시 이 명세의 범위를 벗어나지만 그 위치는 보통 서비스 문서에 제공된다.

엔드포인트 URI는 부록 B에 정의된 대로 “application/x-www-form-urlencoded” 형식으로 포맷된 쿼리 구성 요소([RFC3986] 3.4절)를 포함할 수도 있다(MAY). 이 경우, 추가적인 쿼리 파라미터를 추가할 때 기존 쿼리 구성 요소는 반드시 유지되어야 한다(MUST). 엔드포인트 URI는 프래그먼트(fragment) 구성 요소를 포함해서는 안 된다(MUST NOT).

인가 엔드포인트로의 요청은 사용자 인증과 평문(clear-text) 자격 증명의 전송을 초래하므로(HTTP 응답에서) 인가 서버는 섹션 1.6에 설명된 대로 인가 엔드포인트로 요청을 보낼 때 TLS 사용을 반드시 요구해야 한다(MUST).

인가 서버는 인가 엔드포인트에 대해 HTTP “GET” 메서드[RFC2616]의 사용을 반드시 지원해야 하며(MUST), “POST” 메서드의 사용도 지원할 수 있다(MAY).

값이 없는 상태로 전송된 파라미터는 요청에서 생략된 것처럼 처리되어야 한다(MUST). 인가 서버는 인식하지 못하는 요청 파라미터를 무시해야 한다(MUST). 요청과 응답 파라미터는 한 번을 초과하여 포함되어서는 안 된다(MUST NOT).

#### 3.1.1 응답 유형
인가 엔드포인트는 인가 코드 승인 방식(authorization code grant)과 암시적 승인 방식(implicit grant) 흐름에서 사용된다. 클라이언트는
다음 파라미터를 사용하여 원하는 승인 유형(grant type)을 인가 서버에 알린다.

- response_type 
  - 필수(REQUIRED)이다. 이 값은 반드시 다음 중 하나여야 한다. 섹션 4.1.1에 설명된 대로 인가 코드를 요청하기 위한 "code" 섹션 4.2.1에 설명된 대로 액세스 토큰을 요청하기 위한 "token" (암시적 승인 방식)또는 섹션 8.4에 설명된 대로 등록된 확장 값(registered extension value)

확장 응답 유형(extension response types)은 공백으로 구분된(%x20)여러 값의 목록을 포함할 수도 있다(MAY). 이 경우 값들의 순서는 중요하지 않다(예: "a b"와 "b a"는 동일하다). 이러한 복합 응답 유형의 의미는 각각의 해당 명세에서 정의된다.

인가 요청에 response_type 파라미터가 누락되었거나, 인가 서버가 이해할 수 없는 값인 경우, 인가 서버는 섹션 4.1.2.1에 설명된 대로 오류 응답을 반드시 반환해야 한다(MUST).

#### 3.1.2 리다이렉션 엔드포인트
리소스 소유자와의 상호작용을 마친 후, 인가 서버는 리소스 소유자의 사용자 에이전트를 다시 클라이언트로 이동시킨다. 인가 서버는 클라이언트 등록 과정 중에 또는 인가 요청을 보낼 때 미리 인가 서버와 설정된 클라이언트의 리다이렉션 엔드포인트로 사용자 에이전트를 리다이렉트한다.

리다이렉션 엔드포인트 URI는 [RFC3986] 4.3절에 정의된 대로 반드시 절대 URI(absolute URI)여야 한다(MUST). 엔드포인트 URI는 부록 B에 따라 “application/x-www-form-urlencoded” 형식으로 포맷된 쿼리 구성 요소([RFC3986] 3.4절)를 포함할 수도 있다(MAY). 이 경우, 추가적인 쿼리 파라미터를 추가할 때 기존 쿼리 구성 요소는 반드시 유지되어야 한다(MUST). 엔드포인트 URI는 프래그먼트(fragment) 구성 요소를 포함해서는 안 된다(MUST NOT).

##### 3.1.2.1 엔드포인트 요청 기밀성(추가)
리다이렉션 엔드포인트는, 요청된 응답 유형이 "code" 또는 "token"인 경우이거나, 또는 리다이렉션 요청이 개방된 네트워크를 통해 민감한 자격 증명의 전송을 초래하는 경우에는, 섹션 1.6에 설명된 대로 TLS 사용을 요구하는 것이 바람직하 (SHOULD). 이 명세는 TLS 사용을 의무화하지 않는데, 이는 이 문서가 작성된 시점에서 클라이언트에게 TLS 배포를 요구하는 것이 많은 클라이언트 개발자들에게 상당한 장애물이 되었기 때문이다. TLS를 사용할 수 없는 경우, 인가 서버는 리다이렉션에 앞서 해당 엔드포인트가 안전하지 않다는 점을 리소스 소유자에게 경고하는 것이 바람직하다(SHOULD)(예: 인가 요청 중 메시지를 표시).

전송 계층 보안이 없는 경우는, 클라이언트와 그 클라이언트가 접근 권한을 부여받은 보호된 리소스의 보안에 심각한 영향을 미칠 수 있다. 전송 계층 보안의 사용은 특히, 인가 과정이 클라이언트에 의해 위임된 최종 사용자 인증의 한 형태로 사용되는 경우(예: 제3자 로그인 서비스)에 중요하다.


##### 3.1.2.2 등록 요구 사항
인가 서버는 다음에 해당하는 클라이언트에 대해 리다이렉션 엔드포인트를 반드시 등록하도록 요구해야 한다(MUST).

- 공개 클라이언트(public clients)
- 암시적 승인 방식(implicit grant type)을 사용하는 기밀 클라이언트

인가 서버는 모든 클라이언트가 인가 엔드포인트를 사용하기 전에 리다이렉션 엔드포인트를 등록하도록 요구하는 것이 바람직하다(SHOULD).

인가 서버는 클라이언트가 완전한 리다이렉션 URI 전체를 제공하도록 요구하는 것이 바람직하다(SHOULD) (클라이언트는 요청별 맞춤 처리를 위해 state 요청 파라미터를 사용할 수 있다(MAY)). 만약 완전한 리다이렉션 URI의 등록을 요구하는 것이 불가능한 경우, 인가 서버는 URI 스킴(scheme), 권한(authority), 경로(path)의 등록을 요구하는 것이 바람직하다(SHOULD) (이 경우 클라이언트는 인가 요청 시 리다이렉션 URI의 쿼리 구성 요소만을 동적으로 변경할 수 있다).

인가 서버는 클라이언트가 여러 개의 리다이렉션 엔드포인트를 등록하는 것을 허용할 수 있다(MAY).

리다이렉션 URI 등록 요구 사항이 없는 경우, 섹션 10.15에 설명된 바와 같이
공격자가 인가 엔드포인트를 개방형 리다이렉터(open redirector)로 사용할 수 있게 될 수 있다.

##### 3.1.2.3 동적 구성
여러 개의 리다이렉션 URI가 등록되어 있는 경우, 리다이렉션 URI의 일부만 등록되어 있는 경우, 또는 리다이렉션 URI가 전혀 등록되어 있지 않은 경우에는, 클라이언트는 인가 요청 시 "redirect_uri" 요청 파라미터를 사용하여 반드시 리다이렉션 URI를 포함해야 한다(MUST).

인가 요청에 리다이렉션 URI가 포함된 경우, 인가 서버는 리다이렉션 URI가 하나 이상 등록되어 있다면, 수신한 값이 등록된 리다이렉션 URI(또는 URI 구성 요소) 중 최소 하나와 일치하는지를 [RFC3986] 섹션 6에 정의된 방식에 따라 반드시 비교하고 일치 여부를 확인해야 한다(MUST). 클라이언트 등록 시 완전한 리다이렉션 URI가 포함되어 있었다면, 인가 서버는 [RFC3986] 섹션 6.2.1에 정의된 단순 문자열 비교(simple string comparison) 방식으로 두 URI를 반드시 비교해야 한다(MUST).

##### 3.1.2.4 유효하지 않은 엔드포인트
인가 요청이 누락되었거나, 유효하지 않거나, 또는 일치하지 않는 리다이렉션 URI로 인해 검증에 실패한 경우, 인가 서버는 리소스 소유자에게 해당 오류를 알려야 하며(SHOULD), 유효하지 않은 리다이렉션 URI로 사용자 에이전트를 자동으로 리다이렉트해서는 안 된다(MUST NOT).

##### 3.1.2.5 엔드포인트 콘텐츠
클라이언트의 엔드포인트로 전달되는 리다이렉션 요청은 일반적으로 사용자 에이전트에 의해 처리되는 HTML 문서 응답을 생성한다. 만약 이 HTML 응답이 리다이렉션 요청의 결과로 직접 제공되는 경우, HTML 문서에 포함된 어떠한 스크립트라도 리다이렉션 URI와 그 안에 포함된 자격 증명에 대해 완전한 접근 권한을 가지고 실행된다.

클라이언트는 리다이렉션 엔드포인트 응답에 제3자 스크립트(예: 외부 분석 도구, 소셜 플러그인, 광고 네트워크)를 포함하지 않는 것이 바람직하다(SHOULD NOT). 대신, 클라이언트는 URI로부터 자격 증명을 추출한 뒤, 그 자격 증명을 URI나 다른 위치에 노출하지 않고 사용자 에이전트를 다시 다른 엔드포인트로 리다이렉트하는 것이 바람직하다(SHOULD). 만약 제3자 스크립트가 포함된다면, 클라이언트는 URI로부터 자격 증명을 추출하고 제거하는 데 사용되는 자신의 스크립트가 반드시 먼저 실행되도록 보장해야 한다(MUST).

### 3.2 토큰 엔드포인트
토큰 엔드포인트는 클라이언트가 자신의 권한 부여 승인 정보(authorization grant) 또는 리프레시 토큰(refresh token)을 제시하여 액세스 토큰을 얻기 위해 사용하는 엔드포인트이다. 토큰 엔드포인트는 암시적 승인 방식(implicit grant type)을 제외한 모든 권한 부여 방식에서 사용된다(암시적 승인 방식에서는 액세스 토큰이 직접 발급되기 때문이다).

클라이언트가 토큰 엔드포인트의 위치를 얻는 방법은 이 명세의 범위를 벗어나지만, 해당 위치는 일반적으로 서비스 문서에 제공된다.

엔드포인트 URI는 부록 B에 따라 "application/x-www-form-urlencoded" 형식으로 포맷된 쿼리 구성 요소([RFC3986] 섹션 3.4)를 포함할 수 있다(MAY). 이 경우, 추가적인 쿼리 파라미터를 추가할 때 해당 쿼리 구성 요소는 반드시 유지되어야 한다(MUST). 엔드포인트 URI에는 프래그먼트(fragment) 구성 요소가 포함되어서는 안 된다(MUST NOT).

토큰 엔드포인트로의 요청은 HTTP 요청과 응답에서 평문 자격 증명의 전송을 발생시키므로, 인가 서버는 섹션 1.6에 설명된 대로 토큰 엔드포인트로 요청을 보낼 때 TLS 사용을 반드시 요구해야 한다(MUST).

클라이언트는 액세스 토큰 요청을 수행할 때 HTTP "POST" 메서드를 반드시 사용해야 한다(MUST).

값이 없는 상태로 전송된 파라미터는 요청에서 생략된 것처럼 처리되어야 한다(MUST). 인가 서버는 인식할 수 없는 요청 파라미터를 반드시 무시해야 한다(MUST). 요청 및 응답 파라미터는 한 번을 초과하여 포함되어서는 안 된다(MUST NOT).

#### 3.2.1 클라이언트 인증
기밀 클라이언트(confidential clients) 또는 클라이언트 자격 증명(client credentials)이 발급된 다른 클라이언트는, 토큰 엔드포인트에 요청을 보낼 때 2.3절에 설명된 방식에 따라 반드시 인가 서버와 인증해야 한다(MUST). 클라이언트 인증은 다음과 같은 목적을 위해 사용된다.

- 리프레시 토큰과 인가 코드(authorization code)를 그것들이 발급된 클라이언트에 묶어 두기(binding) 위함이다. 클라이언트 인증은 특히, 인가 코드가 안전하지 않은 채널을 통해 리다이렉션 엔드포인트로 전송되는 경우나, 리다이렉션 URI가 완전히 등록되지 않은 경우에 매우 중요하다.
- 손상(compromised)된 클라이언트로부터 복구하기 위함이다. 즉, 클라이언트를 비활성화하거나 그 자격 증명을 변경함으로써, 공격자가 탈취한 리프레시 토큰을 악용하는 것을 방지한다. 하나의 클라이언트 자격 증명 집합을 변경하는 것은, 전체 리프레시 토큰 집합을 철회(revoke)하는 것보다 훨씬 빠르다.
- 주기적인 자격 증명 교체(credential rotation)를 요구하는 인증 관리 모범 사례(best practices)를 구현하기 위함이다. 전체 리프레시 토큰 집합을 교체하는 것은 어려울 수 있지만, 하나의 클라이언트 자격 증명 집합을 교체하는 것은 훨씬 쉽다.

클라이언트는 토큰 엔드포인트로 요청을 보낼 때, "client_id" 요청 파라미터를 사용하여 자신을 식별할 수도 있다(MAY). "authorization_code" "grant_type" 요청에서, 인증되지 않은 클라이언트는 다른 "client_id"를 가진 클라이언트를 위해 발급된 코드를 실수로 받아들이는 것을 방지하기 위해 반드시 "client_id"를 전송해야 한다(MUST). 이는 인증 코드 치환(substitution)을 방지하기 위한 것이다. (이 조치는 보호된 리소스에 대해 추가적인 보안을 제공하지는 않는다.)

### 3.3 액세스 토큰 범위
인가 엔드포인트와 토큰 엔드포인트는, 클라이언트가 "scope" 요청 파라미터를 사용하여 접근 요청의 범위(scope)를 지정할 수 있도록 허용한다. 이에 따라 인가 서버는 발급된 액세스 토큰의 범위를 클라이언트에게 알리기 위해 "scope" 응답 파라미터를 사용한다.

scope 파라미터의 값은 공백으로 구분된(case-sensitive한) 문자열들의 목록으로 표현된다. 이 문자열들은 인가 서버에 의해 정의된다. 값이 여러 개의 공백으로 구분된 문자열을 포함하는 경우, 문자열들의 순서는 중요하지 않으며, 각 문자열은 요청된 범위에 추가적인 접근 범위를 더한다.

```
scope       = scope-token *( SP scope-token )
scope-token = 1*( %x21 / %x23-5B / %x5D-7E )
```
(위는 scope 값이 어떤 문자들로 구성될 수 있는지를 정의한 문법이다.)

인가 서버는 인가 서버의 정책이나 리소스 소유자의 지침에 따라, 클라이언트가 요청한 scope를 전체 또는 일부 무시할 수 있다(MAY). 만약 발급된 액세스 토큰의 scope가 클라이언트가 요청한 scope와 다르다면, 인가 서버는 실제로 부여된 범위를 클라이언트에게 알리기 위해 "scope" 응답 파라미터를 반드시 포함해야 한다(MUST).

클라이언트가 인가 요청 시 scope 파라미터를 생략한 경우, 인가 서버는 반드시 다음 중 하나를 수행해야 한다(MUST). 미리 정의된 기본(default) scope 값을 사용하여 요청을 처리하거나 scope가 유효하지 않음을 나타내며 요청을 실패시킨다 인가 서버는 자신이 요구하는 scope 조건과 기본 scope 값(정의되어 있다면)을 문서로 명시하는 것이 바람직하다(SHOULD).

## 4. 권한 획득
액세스 토큰을 요청하기 위해, 클라이언트는 리소스 소유자로부터 권한을 획득한다. 이 권한은 인가 그랜트(authorization grant)의 형태로 표현되며, 클라이언트는 이를 사용하여 액세스 토큰을 요청한다. OAuth는 네 가지 그랜트 유형을 정의한다: 인가 코드(authorization code), 암묵적(implicit), 리소스 소유자 비밀번호 자격 증명(resource owner password credentials), 그리고 클라이언트 자격 증명(client credentials). 또한 추가적인 그랜트 유형을 정의하기 위한 확장 메커니즘을 제공한다.

### 4.1 인가 코드 방식
인가 코드 방식은 액세스 토큰과 리프레시 토큰을 모두 획득하기 위해 사용되며, 기밀 클라이언트(confidential clients)에 최적화되어 있다. 이 방식은 리다이렉션 기반 흐름이기 때문에 클라이언트는 리소스 소유자의 사용자 에이전트(일반적으로 웹 브라우저)와 상호작용할 수 있어야 하며 인가 서버로부터의 들어오는 요청을(리다이렉션을 통해) 수신할 수 있어야 한다.

```
     +-----------+
     | 리소스      |
     | 소유자      |
     |           |
     +-----------+
           ^
           |
          (B)
     +-----|------+           클라이언트 식별자        +--------------+
     |           -+----(A)-- 및 리다이렉션 URI ------>|              |
     |  사용자     |                                |   인가 서버    |
     |  에이전트   -+----(B)-- 사용자 인증 ----------->|              |
     |            |                               |              |
     |           -+----(C)-- 인가 코드 ------------<|              |
     +--|----|----+                               +---------------+
        |    |                                        ^       v
       (A)  (C)                                       |       |
        |    |                                        |       |
        ^    v                                        |       |
     +------------+                                   |       |
     |            |>---(D)-- 인가 코드 -----------------'       |
     | 클라이언트    |        및 리다이렉션 URI                     |
     |            |                                           |
     |            |<---(E)----- 액세스 토큰 --------------------'
     +------------+        (선택적 리프레시 토큰 포함)

                        그림 3: 인가 코드 흐름
```
참고: 단계 (A), (B), (C)를 나타내는 선들은 사용자 에이전트를 통과하면서 두 부분으로 나뉘어 표시되어 있다.

그림 3에 나타난 흐름은 다음과 같은 단계들을 포함한다:

(A)
클라이언트는 리소스 소유자의 사용자 에이전트를 인가 엔드포인트로 안내함으로써 흐름을 시작한다. 클라이언트는 자신의 클라이언트 식별자, 요청한 범위(scope), 로컬 상태(local state), 그리고 액세스가 부여되었을 때(또는 거부되었을 때) 인가 서버가 사용자 에이전트를 다시 되돌려 보낼 리다이렉션 URI를 포함한다.

(B)
인가 서버는 사용자 에이전트를 통해 리소스 소유자를 인증하고, 리소스 소유자가 클라이언트의 액세스 요청을 승인하는지 또는 거부하는지를 결정한다.

(C)
리소스 소유자가 액세스를 승인한다고 가정하면, 인가 서버는 이전에 제공된(요청 시 또는 클라이언트 등록 시) 리다이렉션 URI를 사용하여 사용자 에이전트를 다시 클라이언트로 리다이렉션한다. 이 리다이렉션 URI에는 인가 코드와, 클라이언트가 이전에 제공한 모든 로컬 상태가 포함된다.

(D)
클라이언트는 이전 단계에서 수신한 인가 코드를 포함하여 인가 서버의 토큰 엔드포인트에 액세스 토큰을 요청한다. 이 요청을 수행할 때, 클라이언트는 인가 서버에 대해 인증을 수행한다. 또한 클라이언트는 인가 코드를 획득하는 데 사용된 리다이렉션 URI를 검증을 위해 포함한다.

(E)
인가 서버는 클라이언트를 인증하고, 인가 코드를 검증하며, 수신된 리다이렉션 URI가 단계 (C)에서 클라이언트를 리다이렉션하는 데 사용된 URI와 일치하는지를 확인한다. 유효한 경우, 인가 서버는 액세스 토큰을 응답으로 반환하고, 선택적으로 리프레시 토큰을 함께 반환한다.

#### 4.1.1 인가 요청
클라이언트는 부록 B에 따라 "application/x-www-form-urlencoded" 형식을 사용하여, 인가 엔드포인트 URI의 쿼리 구성 요소(query component)에 다음 매개변수들을 추가함으로써 요청 URI를 구성한다: 부록 B.

- response_type
  - 필수(REQUIRED). 값은 반드시 "code"로 설정되어야 한다.

- client_id
  - 필수(REQUIRED). 2.2절에 설명된 클라이언트 식별자.

- redirect_uri
  - 선택(OPTIONAL). 3.1.2절에 설명된 바와 같다.

- scope
  - 선택(OPTIONAL). 3.3절에 설명된 액세스 요청의 범위.

- state
  - 권장(RECOMMENDED). 요청과 콜백 사이에서 상태를 유지하기 위해 클라이언트가 사용하는 불투명한 값. 인가 서버는 사용자 에이전트를 다시 클라이언트로 리다이렉션할 때 이 값을 포함한다. 이 매개변수는 10.12절에 설명된 교차 사이트 요청 위조(cross-site request forgery)를 방지하기 위해 사용되어야 한다(SHOULD).

클라이언트는 HTTP 리다이렉션 응답을 사용하거나, 사용자 에이전트를 통해 이용 가능한 다른 수단을 사용하여, 리소스 소유자를 구성된 URI로 안내한다.

예를 들어, 클라이언트는 사용자 에이전트가 다음과 같은 HTTP 요청을 TLS를 사용하여 수행하도록 안내한다(가독성을 위해 추가적인 줄 바꿈이 포함되어 있음):
```
GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz
    &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
```

인가 서버는 모든 필수 매개변수가 존재하며 유효한지를 확인하기 위해 요청을 검증한다. 요청이 유효한 경우, 인가 서버는 리소스 소유자를 인증하고, 리소스 소유자에게 요청을 묻거나 다른 수단을 통해 승인 여부를 확정함으로써 인가 결정을 획득한다.

결정이 확정되면, 인가 서버는 HTTP 리다이렉션 응답을 사용하거나 사용자 에이전트를 통해 이용 가능한 다른 수단을 사용하여, 사용자 에이전트를 제공된 클라이언트 리다이렉션 URI로 안내한다.

#### 4.1.2 인가 응답 
리소스 소유자가 액세스 요청을 승인한 경우, 인가 서버는 인가 코드를 발급하고, 부록 B에 따라 "application/x-www-form-urlencoded" 형식을 사용하여 리다이렉션 URI의 쿼리 구성 요소에 다음 매개변수들을 추가함으로써 이를 클라이언트에 전달한다:

- code
  - 필수(REQUIRED). 인가 서버에 의해 생성된 인가 코드. 인가 코드는 유출 위험을 완화하기 위해 발급된 후 짧은 시간 내에 만료되어야 한다(MUST). 인가 코드의 최대 유효 기간은 10분을 권장한다 (RECOMMENDED). 클라이언트는 인가 코드를 두 번 이상 사용해서는 안 된다(MUST NOT). 인가 코드가 두 번 이상 사용될 경우, 인가 서버는 요청을 반드시 거부해야 하며(MUST), 가능한 경우 해당 인가 코드를 기반으로 이전에 발급된 모든 토큰을 철회해야 한다(SHOULD). 인가 코드는 클라이언트 식별자와 리다이렉션 URI에 바인딩된다.
- state
  - 클라이언트 인가 요청에 "state" 매개변수가 존재했던 경우 필수 (REQUIRED). 클라이언트로부터 수신한 정확한 값.

예를 들어, 인가 서버는 다음과 같은 HTTP 응답을 전송함으로써 사용자 에이전트를 리다이렉션한다:
```
HTTP/1.1 302 Found
Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
          &state=xyz
```
클라이언트는 인식하지 못하는 응답 매개변수들을 무시해야 한다(MUST). 인가 코드 문자열의 크기는 본 명세에서 정의되지 않는다. 클라이언트는 코드 값의 크기에 대해 가정을 해서는 안 된다. 인가 서버는 자신이 발급하는 모든 값의 크기를 문서화하는 것이 바람직하다(SHOULD).

##### 4.1.2.1 오류 응답
리다이렉션 URI가 누락되었거나, 유효하지 않거나, 일치하지 않는 경우, 또는 클라이언트 식별자가 누락되었거나 유효하지 않은 경우로 인해 요청이 실패하면, 인가 서버는 리소스 소유자에게 오류를 알려야 하며(SHOULD), 유효하지 않은 리다이렉션 URI로 사용자 에이전트를 자동으로 리다이렉션해서는 안 된다(MUST NOT).

리소스 소유자가 액세스 요청을 거부한 경우, 또는 리다이렉션 URI의 누락이나 유효하지 않음 이외의 이유로 요청이 실패한 경우, 인가 서버는 부록 B에 따라 "application/x-www-form-urlencoded" 형식을 사용하여 리다이렉션 URI의 쿼리 구성 요소에 다음 매개변수들을 추가함으로써 클라이언트에 이를 알린다:

error 필수(REQUIRED). 다음 중 하나의 단일 ASCII [USASCII] 오류 코드:
- invalid_request
  - 요청에 필수 매개변수가 누락되었거나, 유효하지 않은 매개변수 값이 포함되었거나, 매개변수가 두 번 이상 포함되었거나, 그 외의 방식으로 잘못 형성된 경우.
- unauthorized_client
  - 클라이언트가 이 방법을 사용하여 인가 코드를 요청할 수 있도록 인가되지 않은 경우.
- access_denied
  - 리소스 소유자 또는 인가 서버가 요청을 거부한 경우.
- unsupported_response_type
  - 인가 서버가 이 방법을 사용한 인가 코드 획득을 지원하지 않는 경우.
- invalid_scope
  - 요청된 범위(scope)가 유효하지 않거나, 알 수 없거나, 잘못 형성된 경우.
- server_error
  - 인가 서버가 요청을 처리하는 것을 방해하는 예기치 않은 상태를 만난 경우. (이 오류 코드는 HTTP 리다이렉션을 통해 클라이언트에 500 Internal Server Error 상태 코드를 반환할 수 없기 때문에 필요하다.)
- temporarily_unavailable
  - 서버의 일시적인 과부하 또는 유지보수로 인해 인가 서버가 현재 요청을 처리할 수 없는 경우.(이 오류 코드는 HTTP 리다이렉션을 통해 클라이언트에 503 Service Unavailable 상태 코드를 반환할 수 없기 때문에 필요하다.)

"error" 매개변수의 값에는 %x20-21 / %x23-5B / %x5D-7E 집합에 포함되지 않은 문자가 포함되어서는 안 된다(MUST NOT).

- error_description
  - 선택(OPTIONAL). 발생한 오류를 이해하는 데 도움을 주기 위해 클라이언트 개발자를 보조하는, 사람이 읽을 수 있는 ASCII [USASCII] 텍스트 형태의 추가 정보. "error_description" 매개변수의 값에는 %x20-21 / %x23-5B / %x5D-7E 집합에 포함되지 않은 문자가 포함되어서는 안 된다(MUST NOT).
- error_uri
  - 선택(OPTIONAL). 오류에 대한 정보를 포함한 사람이 읽을 수 있는 웹 페이지를 식별하는 URI로, 클라이언트 개발자에게 오류에 대한 추가 정보를 제공하는 데 사용된다. "error_uri" 매개변수의 값은 URI-reference 구문을 따라야 하며, 따라서 %x21 / %x23-5B / %x5D-7E 집합에 포함되지 않은 문자를 포함해서는 안 된다(MUST NOT).
- state
  - 클라이언트 인가 요청에 "state" 매개변수가 존재했던 경우 필수 (REQUIRED). 클라이언트로부터 수신한 정확한 값.

예를 들어, 인가 서버는 다음과 같은 HTTP 응답을 전송함으로써 사용자 에이전트를 리다이렉션한다:
```
HTTP/1.1 302 Found
Location: https://client.example.com/cb?error=access_denied&state=xyz
```

#### 4.1.3 액세스 토큰 요청
클라이언트는 부록 B에 따라 "application/x-www-form-urlencoded" 형식을 사용하고, HTTP 요청 엔터티 본문(entity-body)에 UTF-8 문자 인코딩을 적용하여, 다음 매개변수들을 전송함으로써 토큰 엔드포인트에 요청을 보낸다:

- grant_type
  - 필수(REQUIRED). 값은 반드시 "authorization_code"로 설정되어야 한다.
- code
  - 필수(REQUIRED). 인가 서버로부터 수신한 인가 코드.
- redirect_uri
  - 4.1.1절에 설명된 바와 같이, 인가 요청에 "redirect_uri" 매개변수가 포함되었던 경우 필수(REQUIRED)이며, 그 값은 반드시 동일해야 한다.
- client_id
  - 3.2.1절에 설명된 바와 같이 클라이언트가 인가 서버에 대해 인증을 수행하지 않는 경우 필수(REQUIRED).

클라이언트 유형이 기밀 클라이언트이거나, 클라이언트 자격 증명이 발급되었거나(또는 다른 인증 요구 사항이 할당된 경우), 클라이언트는 3.2.1절에 설명된 바와 같이 인가 서버에 대해 반드시 인증을 수행해야 한다(MUST).

예를 들어, 클라이언트는 TLS를 사용하여 다음과 같은 HTTP 요청을 보낸다(가독성을 위해 추가적인 줄 바꿈이 포함되어 있음):

```
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
```

인가 서버는 다음을 반드시 수행해야 한다(MUST):
- 기밀 클라이언트이거나 클라이언트 자격 증명이 발급된 모든 클라이언트(또는 다른 인증 요구 사항이 있는 클라이언트)에 대해 클라이언트 인증을 요구해야 한다.
- 클라이언트 인증이 포함된 경우, 클라이언트를 인증해야 한다.
- 인가 코드가 인증된 기밀 클라이언트에 발급된 것인지 확인하거나, 클라이언트가 공개 클라이언트인 경우 요청에 포함된 "client_id"에 발급된 코드인지 확인해야 한다.
- 인가 코드가 유효한지 검증해야 한다.
- 4.1.1절에 설명된 초기 인가 요청에 "redirect_uri" 매개변수가 포함되어 있었던 경우, "redirect_uri" 매개변수가 존재하는지 확인해야 하며, 포함된 경우 그 값이 반드시 동일한지 확인해야 한다.

#### 4.1.4 액세스 토큰 응답
액세스 토큰 요청이 유효하고 인가된 경우, 인가 서버는 5.1절에 설명된 바와 같이 액세스 토큰과 선택적인 리프레시 토큰을 발급한다. 요청 클라이언트 인증이 실패했거나 유효하지 않은 경우, 인가 서버는 5.2절에 설명된 바와 같이 오류 응답을 반환한다.

성공적인 응답의 예는 다음과 같다:
```
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"example",
  "expires_in":3600,
  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
  "example_parameter":"example_value"
}
```

### 4.2 암묵적 방식
암묵적 방식은 액세스 토큰을 획득하기 위해 사용되며(리프레시 토큰 발급은 지원하지 않는다), 특정 리다이렉션 URI에서 동작하는 것으로 알려진 공개 클라이언트(public clients)에 최적화되어 있다. 이러한 클라이언트는 일반적으로 JavaScript와 같은 스크립트 언어를 사용하여 브라우저에서 구현된다.

이 방식은 리다이렉션 기반 흐름이므로, 클라이언트는 리소스 소유자의 사용자 에이전트(일반적으로 웹 브라우저)와 상호작용할 수 있어야 하며, 인가 서버로부터의 들어오는 요청을(리다이렉션을 통해) 수신할 수 있어야 한다.

인가 코드 방식과 달리, 클라이언트가 인가 요청과 액세스 토큰 요청을 별도로 수행하는 대신, 클라이언트는 인가 요청의 결과로 액세스 토큰을 직접 수신한다.

암묵적 방식에는 클라이언트 인증이 포함되지 않으며, 리소스 소유자의 존재와 리다이렉션 URI의 등록에 의존한다. 액세스 토큰이 리다이렉션 URI에 인코딩되기 때문에, 동일한 장치에 존재하는 리소스 소유자 및 다른 애플리케이션에 노출될 수 있다.

```
     +----------+
     | 리소스     |
     | 소유자     |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          클라이언트 식별자       +---------------+
     |         -+----(A)-- 및 리다이렉션 URI ---> |               |
     |  사용자    |                              |   인가 서버     |
     |  에이전트 -|----(B)-- 사용자 인증 -------->  |               |
     |          |                              |               |
     |          |<---(C)--- 리다이렉션 URI ------<|               |
     |          |          (프래그먼트에          +---------------+
     |          |           액세스 토큰 포함)
     |          |                               +---------------+
     |          |----(D)--- 리다이렉션 URI ------> |  웹 호스팅된   |
     |          |          (프래그먼트 제외)        |   클라이언트   |
     |          |                               |    리소스     |
     |     (F)  |<---(E)------- 스크립트 --------<|              |
     |          |                               +---------------+
     +-|--------+
       |    |
      (A)  (G) 액세스 토큰
       |    |
       ^    v
     +---------+
     |         |
     | 클라이언트 |
     |         |
     +---------+
                    그림 4: 암묵적 방식 흐름
```

참고: 단계 (A)와 (B)를 나타내는 선들은 사용자 에이전트를 통과하면서 두 부분으로 나뉘어 표시되어 있다.

그림 4에 나타난 흐름은 다음과 같은 단계들을 포함한다:
(A)
클라이언트는 리소스 소유자의 사용자 에이전트를 인가 엔드포인트로 안내함으로써 흐름을 시작한다. 클라이언트는 자신의 클라이언트 식별자, 요청한 범위(scope), 로컬 상태(local state), 그리고 액세스가 부여되었을 때(또는 거부되었을 때) 인가 서버가 사용자 에이전트를 다시 되돌려 보낼 리다이렉션 URI를 포함한다.

(B)
인가 서버는 사용자 에이전트를 통해 리소스 소유자를 인증하고, 리소스 소유자가 클라이언트의 액세스 요청을 승인하는지 또는 거부하는지를 결정한다.

(C)
리소스 소유자가 액세스를 승인한다고 가정하면, 인가 서버는 이전에 제공된 리다이렉션 URI를 사용하여 사용자 에이전트를 다시 클라이언트로 리다이렉션한다. 이 리다이렉션 URI에는 URI 프래그먼트(fragment)에 액세스 토큰이 포함된다.

(D)
사용자 에이전트는 리다이렉션 지시에 따라 웹에 호스팅된 클라이언트 리소스에 요청을 보낸다(이 요청에는 [RFC2616]에 따라 프래그먼트가 포함되지 않는다). 사용자 에이전트는 프래그먼트 정보를 로컬에 유지한다.

(E)
웹에 호스팅된 클라이언트 리소스는 사용자 에이전트가 유지하고 있는 프래그먼트를 포함한 전체 리다이렉션 URI에 접근할 수 있고, 프래그먼트에 포함된 액세스 토큰(및 기타 매개변수)을 추출할 수 있는 웹 페이지(일반적으로 스크립트가 포함된 HTML 문서)를 반환한다.

(F)
사용자 에이전트는 웹에 호스팅된 클라이언트 리소스가 제공한 스크립트를 로컬에서 실행하여, 액세스 토큰을 추출한다.

(G)
사용자 에이전트는 액세스 토큰을 클라이언트에 전달한다.

암묵적 방식 사용에 대한 배경은 1.3.2절과 9절을 참조한다. 암묵적 방식을 사용할 때의 중요한 보안 고려 사항은 10.3절과 10.16절을 참조한다.

#### 4.2.1 인가 요청
클라이언트는 부록 B에 따라 "application/x-www-form-urlencoded" 형식을 사용하여, 인가 엔드포인트 URI의 쿼리 구성 요소에 다음 매개변수들을 추가함으로써 요청 URI를 구성한다:

- response_type
  - 필수(REQUIRED). 값은 반드시 "token"으로 설정되어야 한다.
- client_id
  - 필수(REQUIRED). 2.2절에 설명된 클라이언트 식별자.
- redirect_uri
  - 선택(OPTIONAL). 3.1.2절에 설명된 바와 같다.
- scope
  - 선택(OPTIONAL). 3.3절에 설명된 액세스 요청의 범위.
- state
  - 권장(RECOMMENDED). 요청과 콜백 사이에서 상태를 유지하기 위해 클라이언트가 사용하는 불투명한 값. 인가 서버는 사용자 에이전트를 다시 클라이언트로 리다이렉션할 때 이 값을 포함한다. 이 매개변수는 10.12절에 설명된 교차 사이트 요청 위조(cross-site request forgery) 를 방지하기 위해 사용되어야 한다(SHOULD).

클라이언트는 HTTP 리다이렉션 응답을 사용하거나, 사용자 에이전트를 통해 이용 가능한 다른 수단을 사용하여, 리소스 소유자를 구성된 URI로 안내한다.

예를 들어, 클라이언트는 사용자 에이전트가 다음과 같은 HTTP 요청을 TLS를 사용하여 수행하도록 안내한다(가독성을 위해 추가적인 줄 바꿈이 포함되어 있음):
```
GET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz
    &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
```

인가 서버는 모든 필수 매개변수가 존재하며 유효한지를 확인하기 위해 요청을 검증한다. 인가 서버는 3.1.2절에 설명된 바와 같이, 액세스 토큰을 리다이렉션할 대상이 되는 리다이렉션 URI가 클라이언트에 의해 등록된 리다이렉션 URI와 일치하는지를 반드시 검증해야 한다(MUST).

요청이 유효한 경우, 인가 서버는 리소스 소유자를 인증하고, 리소스 소유자에게 요청을 묻거나 다른 수단을 통해 승인 여부를 확정함으로써 인가 결정을 획득한다.

결정이 확정되면, 인가 서버는 HTTP 리다이렉션 응답을 사용하거나 사용자 에이전트를 통해 이용 가능한 다른 수단을 사용하여, 사용자 에이전트를 제공된 클라이언트 리다이렉션 URI로 안내한다.

#### 4.2.2 액세스 토큰 응답
리소스 소유자가 액세스 요청을 승인한 경우, 인가 서버는 부록 B에 따라 "application/x-www-form-urlencoded" 형식을 사용하여 리다이렉션 URI의 프래그먼트 구성 요소에 다음 매개변수들을 추가함으로써 액세스 토큰을 발급하고 이를 클라이언트에 전달한다:
- access_token
  - 필수(REQUIRED). 인가 서버에 의해 발급된 액세스 토큰.
- token_type
  - 필수(REQUIRED). 7.1절에 설명된 바와 같이 발급된 토큰의 유형. 값은 대소문자를 구분하지 않는다.
- expires_in
  - 권장(RECOMMENDED). 액세스 토큰의 수명(초 단위). 예를 들어, 값 "3600"은 응답이 생성된 시점으로부터 액세스 토큰이 1시간 후에 만료됨을 의미한다. 생략된 경우, 인가 서버는 다른 수단을 통해 만료 시간을 제공하거나 기본값을 문서화하는 것이 바람직하다(SHOULD).
- scope
  - 클라이언트가 요청한 범위(scope)와 동일한 경우 선택(OPTIONAL), 그렇지 않은 경우 필수(REQUIRED). 3.3절에 설명된 액세스 토큰의 범위.
- state
  - 클라이언트 인가 요청에 "state" 매개변수가 존재했던 경우 필수 (REQUIRED). 클라이언트로부터 수신한 정확한 값.

인가 서버는 리프레시 토큰을 발급해서는 안 된다(MUST NOT).

예를 들어, 인가 서버는 다음과 같은 HTTP 응답을 전송함으로써 사용자 에이전트를 리다이렉션한다(가독성을 위해 추가적인 줄 바꿈이 포함되어 있음):
```
HTTP/1.1 302 Found
Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA
          &state=xyz&token_type=example&expires_in=3600
```
개발자는 일부 사용자 에이전트가 HTTP “Location” 응답 헤더 필드에 프래그먼트 구성 요소를 포함하는 것을 지원하지 않는다는 점에 유의해야 한다. 이러한 클라이언트의 경우, 3xx 리다이렉션 응답 대신 클라이언트를 리다이렉션하기 위한 다른 방법을 사용해야 한다. 예를 들어, 리다이렉션 URI에 연결된 동작을 가진 ‘continue’ 버튼을 포함하는 HTML 페이지를 반환하는 방식이 있다.

클라이언트는 인식하지 못하는 응답 매개변수들을 무시해야 한다(MUST). 액세스 토큰 문자열의 크기는 본 명세에서 정의되지 않는다. 클라이언트는 값의 크기에 대해 가정을 해서는 안 된다. 인가 서버는 자신이 발급하는 모든 값의 크기를 문서화하는 것이 바람직하다(SHOULD).

##### 4.2.2.1 오류 응답
리다이렉션 URI가 누락되었거나, 유효하지 않거나, 일치하지 않는 경우, 또는 클라이언트 식별자가 누락되었거나 유효하지 않은 경우로 인해 요청이 실패하면, 인가 서버는 리소스 소유자에게 오류를 알려야 하며(SHOULD), 유효하지 않은 리다이렉션 URI로 사용자 에이전트를 자동으로 리다이렉션해서는 안 된다(MUST NOT).

리소스 소유자가 액세스 요청을 거부한 경우, 또는 리다이렉션 URI의 누락이나 유효하지 않음 이외의 이유로 요청이 실패한 경우, 인가 서버는 부록 B에 따라 "application/x-www-form-urlencoded" 형식을 사용하여 리다이렉션 URI의 프래그먼트 구성 요소에 다음 매개변수들을 추가함으로써 클라이언트에 이를 알린다:

error 필수(REQUIRED)다음 중 하나의 단일 ASCII [USASCII] 오류 코드:
- invalid_request
  - 요청에 필수 매개변수가 누락되었거나, 유효하지 않은 매개변수 값이 포함되었거나, 매개변수가 두 번 이상 포함되었거나, 그 외의 방식으로 잘못 형성된 경우.
- unauthorized_client
  - 클라이언트가 이 방법을 사용하여 액세스 토큰을 요청할 수 있도록 인가되지 않은 경우.
- access_denied
  - 리소스 소유자 또는 인가 서버가 요청을 거부한 경우.
- unsupported_response_type
  - 인가 서버가 이 방법을 사용한 액세스 토큰 획득을 지원하지 않는 경우.
- invalid_scope
  - 요청된 범위(scope)가 유효하지 않거나, 알 수 없거나, 잘못 형성된 경우.
- server_error
  - 인가 서버가 요청을 처리하는 것을 방해하는 예기치 않은 상태를 만난 경우. (이 오류 코드는 HTTP 리다이렉션을 통해 클라이언트에 500 Internal Server Error 상태 코드를 반환할 수 없기 때문에 필요하다.)
- temporarily_unavailable 
  - 서버의 일시적인 과부하 또는 유지보수로 인해 인가 서버가 현재 요청을 처리할 수 없는 경우. (이 오류 코드는 HTTP 리다이렉션을 통해 클라이언트에 503 Service Unavailable 상태 코드를 반환할 수 없기 때문에 필요하다.)

"error" 매개변수의 값에는 %x20-21 / %x23-5B / %x5D-7E 집합에 포함되지 않은 문자가 포함되어서는 안 된다(MUST NOT).

### 4.3 리소스 소유자 비밀번호 자격 증명 방식
리소스 소유자 비밀번호 자격 증명 방식은 장치 운영체제나 고도의 권한을 가진 애플리케이션과 같이, 리소스 소유자가 클라이언트와 신뢰 관계를 가지고 있는 경우에 적합하다. 인가 서버는 이 그랜트 유형을 활성화할 때 특별한 주의를 기울여야 하며, 다른 흐름들이 적합하지 않은 경우에만 이를 허용해야 한다.

이 그랜트 유형은 리소스 소유자의 자격 증명(일반적으로 대화형 폼을 통해 입력되는 사용자 이름과 비밀번호)을 획득할 수 있는 클라이언트에 적합하다. 또한 이 방식은 HTTP Basic 또는 Digest 인증과 같은 직접 인증 방식을 사용하는 기존 클라이언트를, 저장된 자격 증명을 액세스 토큰으로 변환함으로써 OAuth로 마이그레이션하는 데에도 사용된다.
```
     +----------+
     | 리소스   |
     | 소유자   |
     |          |
     +----------+
          v
          |    리소스 소유자
         (A)   비밀번호 자격 증명
          |
          v
     +---------+                                +---------------+
     |         |>--(B)---- 리소스 소유자 --------> |               |
     |         |         비밀번호 자격 증명         |   인가 서버     |
     | 클라이언트|                                |               |
     |         |<--(C)---- 액세스 토큰 ----------<|               |
     |         |    (선택적 리프레시 토큰 포함)       |               |
     +---------+                                +---------------+
                  그림 5: 리소스 소유자 비밀번호 자격 증명 흐름
```
그림 5에 나타난 흐름은 다음과 같은 단계들을 포함한다:

(A)
리소스 소유자는 자신의 사용자 이름과 비밀번호를 클라이언트에 제공한다.

(B)
클라이언트는 리소스 소유자로부터 수신한 자격 증명을 포함하여 인가 서버의 토큰 엔드포인트에 액세스 토큰을 요청한다. 이 요청을 수행할 때, 클라이언트는 인가 서버에 대해 인증을 수행한다.

(C)
인가 서버는 클라이언트를 인증하고 리소스 소유자의 자격 증명을 검증하며, 유효한 경우 액세스 토큰을 발급한다.

#### 4.3.1. 인가 요청 및 응답
클라이언트가 리소스 소유자의 자격 증명을 획득하는 방식은 본 명세의 범위를 벗어난다. 클라이언트는 액세스 토큰을 획득한 이후에는 해당 자격 증명을 반드시 폐기해야 한다(MUST).

#### 4.3.2 액세스 토큰 요청
클라이언트는 부록 B에 따라 "application/x-www-form-urlencoded" 형식을 사용하고, HTTP 요청 엔터티 본문(entity-body)에 UTF-8 문자 인코딩을 적용하여, 다음 매개변수들을 추가함으로써 토큰 엔드포인트에 요청을 보낸다:

- grant_type
  - 필수(REQUIRED). 값은 반드시 "password"로 설정되어야 한다.
- username
  - 필수(REQUIRED). 리소스 소유자의 사용자 이름.
- password
  - 필수(REQUIRED). 리소스 소유자의 비밀번호.
- scope
  - 선택(OPTIONAL). 3.3절에 설명된 액세스 요청의 범위.

클라이언트 유형이 기밀 클라이언트이거나, 클라이언트 자격 증명이 발급되었거나(또는 다른 인증 요구 사항이 할당된 경우), 클라이언트는 3.2.1절에 설명된 바와 같이 인가 서버에 대해 반드시 인증을 수행해야 한다(MUST).

예를 들어, 클라이언트는 전송 계층 보안(transport-layer security)을 사용하여 다음과 같은 HTTP 요청을 보낸다(가독성을 위해 추가적인 줄 바꿈이 포함되어 있음):
```
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=password&username=johndoe&password=A3ddj3w
```

인가 서버는 다음을 반드시 수행해야 한다(MUST):
- 기밀 클라이언트이거나 클라이언트 자격 증명이 발급된 모든 클라이언트(또는 다른 인증 요구 사항이 있는 클라이언트)에 대해 클라이언트 인증을 요구해야 한다.
- 클라이언트 인증이 포함된 경우, 클라이언트를 인증해야 한다.
- 기존의 비밀번호 검증 알고리즘을 사용하여 리소스 소유자의 비밀번호 자격 증명을 검증해야 한다.

이 액세스 토큰 요청은 리소스 소유자의 비밀번호를 사용하므로, 인가 서버는 무차별 대입 공격(brute force attack)에 대해 엔드포인트를 반드시 보호해야 한다(MUST). (예: 요청 속도 제한(rate-limitation) 적용 또는 경고 생성)

#### 4.3.3 액세스 토큰 응답
액세스 토큰 요청이 유효하고 인가된 경우, 인가 서버는 5.1절에 설명된 바와 같이 액세스 토큰과 선택적인 리프레시 토큰을 발급한다. 요청에서 클라이언트 인증이 실패했거나 요청이 유효하지 않은 경우, 인가 서버는 5.2절에 설명된 바와 같이 오류 응답을 반환한다.

성공적인 응답의 예는 다음과 같다:
```
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"example",
  "expires_in":3600,
  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
  "example_parameter":"example_value"
}
```

### 4.4 클라이언트 자격 증명 방식
클라이언트는 보호된 리소스가 자신의 제어 하에 있거나, 또는 인가 서버와 사전에 합의된 다른 리소스 소유자의 리소스에 접근을 요청하는 경우(그 방법은 본 명세의 범위를 벗어난다), 자신의 클라이언트 자격 증명(또는 기타 지원되는 인증 수단)만을 사용하여 액세스 토큰을 요청할 수 있다.

클라이언트 자격 증명 방식은 반드시 기밀 클라이언트에서만 사용되어야 한다(MUST).
```
     +---------+                                  +---------------+
     |         |                                  |               |
     |         |>--(A)-- 클라이언트 인증 ------------>|   인가 서버     |
     | 클라이언트 |                                   |               |
     |         |<--(B)---- 액세스 토큰 -------------<|               |
     |         |                                  |               |
     +---------+                                  +---------------+
                  그림 6: 클라이언트 자격 증명 흐름
```
그림 6에 나타난 흐름은 다음과 같은 단계들을 포함한다:

(A)
클라이언트는 인가 서버에 대해 인증을 수행하고, 토큰 엔드포인트에 액세스 토큰을 요청한다.

(B)
인가 서버는 클라이언트를 인증하고, 유효한 경우 액세스 토큰을 발급한다.

#### 4.4.1 인가 요청 및 응답
클라이언트 인증이 인가 그랜트로 사용되므로, 추가적인 인가 요청은 필요하지 않다.

#### 4.4.2 액세스 토큰 요청
클라이언트는 부록 B에 따라 "application/x-www-form-urlencoded" 형식을 사용하고, HTTP 요청 엔터티 본문(entity-body)에 UTF-8 문자 인코딩을 적용하여, 다음 매개변수들을 추가함으로써 토큰 엔드포인트에 요청을 보낸다:

- grant_type
  - 필수(REQUIRED). 값은 반드시 "client_credentials"로 설정되어야 한다.
- scope
  - 선택(OPTIONAL). 3.3절에 설명된 액세스 요청의 범위.


클라이언트는 3.2.1절에 설명된 바와 같이 인가 서버에 대해 반드시 인증을 수행해야 한다(MUST).

예를 들어, 클라이언트는 전송 계층 보안(transport-layer security)을 사용하여 다음과 같은 HTTP 요청을 보낸다(가독성을 위해 추가적인 줄 바꿈이 포함되어 있음):

```
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
```
인가 서버는 클라이언트를 반드시 인증해야 한다(MUST).

### 4.4.3 액세스 토큰 응답
액세스 토큰 요청이 유효하고 인가된 경우, 인가 서버는 5.1절에 설명된 바와 같이 액세스 토큰을 발급한다. 리프레시 토큰은 포함되지 않는 것이 바람직하다(SHOULD NOT). 요청에서 클라이언트 인증이 실패했거나 요청이 유효하지 않은 경우, 인가 서버는 5.2절에 설명된 바와 같이 오류 응답을 반환한다.

성공적인 응답의 예는 다음과 같다:

```
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"example",
  "expires_in":3600,
  "example_parameter":"example_value"
}
```

### 4.5 확장 승인
클라이언트는 토큰 엔드포인트의 "grant_type" 매개변수 값으로 인가 서버에 의해 정의된 절대 URI를 지정하고, 필요한 추가 매개변수들을 더함으로써 확장 그랜트 유형을 사용한다.

예를 들어, [OAuth-SAML2]에 정의된 보안 어설션 마크업 언어(Security Assertion Markup Language, SAML) 2.0 어설션 그랜트 유형을 사용하여 액세스 토큰을 요청하기 위해, 클라이언트는 TLS를 사용하여 다음과 같은 HTTP 요청을 보낼 수 있다(가독성을 위해 추가적인 줄 바꿈이 포함되어 있음):

```
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-
bearer&assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU
[...간결성을 위해 생략됨...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-
```
액세스 토큰 요청이 유효하고 인가된 경우, 인가 서버는 5.1절에 설명된 바와 같이 액세스 토큰과 선택적인 리프레시 토큰을 발급한다. 요청에서 클라이언트 인증이 실패했거나 요청이 유효하지 않은 경우, 인가 서버는 5.2절에 설명된 바와 같이 오류 응답을 반환한다.

## 5. 액세스 토큰 발급
액세스 토큰 요청이 유효하고 인가된 경우, 인가 서버는 5.1절에 설명된 바와 같이 액세스 토큰과 선택적으로 리프레시 토큰을 발급한다. 요청에서 클라이언트 인증이 실패했거나 요청이 유효하지 않은 경우, 인가 서버는 5.2절에 설명된 오류 응답을 반환한다.

### 5.1 성공 응답
인가 서버는 액세스 토큰과 선택적으로 리프레시 토큰을 발급하며, HTTP 응답의 엔터티 본문(entity-body)에 다음 매개변수들을 추가하여 200(OK) 상태 코드의 응답을 구성한다:

- access_token
  - 필수(REQUIRED). 인가 서버에 의해 발급된 액세스 토큰.
- token_type
  - 필수(REQUIRED). 7.1절에 설명된 바와 같이 발급된 토큰의 유형. 값은 대소문자를 구분하지 않는다.
- expires_in
  - 권장(RECOMMENDED). 액세스 토큰의 수명(초 단위). 예를 들어 값 “3600”은 응답이 생성된 시점으로부터 액세스 토큰이 1시간 후에 만료됨을 의미한다. 이 값이 생략된 경우, 인가 서버는 다른 수단을 통해 만료 시간을 제공하거나 기본값을 문서화하는 것이 바람직하다(SHOULD).
- refresh_token
  - 선택(OPTIONAL). 6절에 설명된 바와 같이, 동일한 인가 그랜트를 사용하여 새로운 액세스 토큰을 획득하는 데 사용할 수 있는 리프레시 토큰.
- scope
  - 클라이언트가 요청한 범위(scope)와 동일한 경우 선택(OPTIONAL)이며, 그렇지 않은 경우 필수(REQUIRED). 3.3절에 설명된 액세스 토큰의 범위.

이 매개변수들은 [RFC4627]에 정의된 "application/json" 미디어 타입을 사용하여 HTTP 응답의 엔터티 본문에 포함된다. 각 매개변수는 최상위 구조 수준에 추가함으로써 JavaScript Object Notation(JSON) 구조로 직렬화된다. 매개변수 이름과 문자열 값은 JSON 문자열로 포함되며, 숫자 값은 JSON 숫자로 포함된다. 매개변수의 순서는 중요하지 않으며 달라질 수 있다.

인가 서버는 토큰, 자격 증명 또는 기타 민감한 정보를 포함하는 모든 응답에 대해, 값이 "no-store"인 HTTP "Cache-Control" 응답 헤더 필드[RFC2616]와, 값이 "no-cache"인 "Pragma" 응답 헤더 필드[RFC2616]를 반드시 포함해야 한다(MUST).

예를 들면 다음과 같다:
```
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  "token_type":"example",
  "expires_in":3600,
  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
  "example_parameter":"example_value"
}
```

클라이언트는 응답에 포함된 인식하지 못하는 값 이름을 무시해야 한다(MUST). 인가 서버로부터 수신하는 토큰 및 기타 값들의 크기는 본 명세에서 정의되지 않는다. 클라이언트는 값의 크기에 대해 가정을 피해야 한다. 인가 서버는 자신이 발급하는 모든 값의 크기를 문서화하는 것이 바람직하다(SHOULD).

### 5.2 오류 응답
인가 서버는 (달리 명시되지 않는 한) HTTP 400(Bad Request) 상태 코드로 응답하며, 응답에 다음 매개변수들을 포함한다:

error 필수(REQUIRED). 다음 중 하나의 단일 ASCII [USASCII] 오류 코드:
- invalid_request
  - 요청에 필수 매개변수가 누락되었거나, (그랜트 타입을 제외한) 지원되지 않는 매개변수 값이 포함되었거나, 매개변수가 반복되었거나, 여러 자격 증명이 포함되었거나, 클라이언트 인증을 위해 하나 이상의 메커니즘을 사용했거나, 그 밖에 요청 형식이 잘못된 경우.
- invalid_client
  - 클라이언트 인증이 실패한 경우(예: 알 수 없는 클라이언트, 클라이언트 인증이 포함되지 않은 경우, 또는 지원되지 않는 인증 방식). 인가 서버는 어떤 HTTP 인증 방식이 지원되는지를 나타내기 위해 HTTP 401(Unauthorized) 상태 코드를 반환할 수 있다(MAY). 클라이언트가 "Authorization" 요청 헤더 필드를 통해 인증을 시도한 경우, 인가 서버는 반드시 HTTP 401(Unauthorized) 상태 코드로 응답해야 하며(MUST), 클라이언트가 사용한 인증 방식과 일치하는 "WWW-Authenticate" 응답 헤더 필드를 포함해야 한다.
- invalid_grant
  - 제공된 인가 그랜트(예: 인가 코드, 리소스 소유자 자격 증명) 또는 리프레시 토큰이 유효하지 않거나, 만료되었거나, 철회되었거나, 인가 요청에서 사용된 리다이렉션 URI와 일치하지 않거나, 다른 클라이언트에 발급된 경우.
- unauthorized_client
  - 인증된 클라이언트가 이 인가 그랜트 유형을 사용할 권한이 없는 경우.
- unsupported_grant_type
  - 인가 서버가 해당 인가 그랜트 유형을 지원하지 않는 경우.
- invalid_scope
  - 요청된 범위(scope)가 유효하지 않거나, 알 수 없거나, 형식이 잘못되었거나, 리소스 소유자가 부여한 범위를 초과한 경우.

"error" 매개변수의 값에는 %x20-21 / %x23-5B / %x5D-7E 집합에 포함되지 않은 문자가 포함되어서는 안 된다(MUST NOT).

- error_description
  - 선택(OPTIONAL). 발생한 오류를 이해하는 데 도움을 주기 위해 클라이언트 개발자를 보조하는, 사람이 읽을 수 있는 ASCII [USASCII] 텍스트 형태의 추가 정보. "error_description" 매개변수의 값에는 %x20-21 / %x23-5B / %x5D-7E 집합에 포함되지 않은 문자가 포함되어서는 안 된다(MUST NOT).
- error_uri
  - 선택(OPTIONAL). 오류에 대한 정보를 포함한 사람이 읽을 수 있는 웹 페이지를 식별하는 URI로, 클라이언트 개발자에게 오류에 대한 추가 정보를 제공하는 데 사용된다. "error_uri" 매개변수의 값은 URI-reference 구문을 따라야 하며, 따라서 %x21 / %x23-5B / %x5D-7E 집합에 포함되지 않은 문자를 포함해서는 안 된다(MUST NOT).

이 매개변수들은 [RFC4627]에 정의된 "application/json" 미디어 타입을 사용하여 HTTP 응답의 엔터티 본문에 포함된다. 각 매개변수는 최상위 구조 수준에 추가함으로써 JSON 구조로 직렬화된다. 매개변수 이름과 문자열 값은 JSON 문자열로 포함되며, 숫자 값은 JSON 숫자로 포함된다. 매개변수의 순서는 중요하지 않으며 달라질 수 있다.

예를 들면 다음과 같다:
```
HTTP/1.1 400 Bad Request
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "error":"invalid_request"
}
```

## 6. 액세스 토큰 갱신
인가 서버가 클라이언트에게 리프레시 토큰을 발급한 경우, 클라이언트는 부록 B에 따라 "application/x-www-form-urlencoded" 형식을 사용하고, HTTP 요청 엔터티 본문(entity-body)에 UTF-8 문자 인코딩을 적용하여 다음 매개변수들을 추가함으로써 토큰 엔드포인트에 리프레시 요청을 보낸다:

- grant_type
  - 필수(REQUIRED). 값은 반드시 "refresh_token"으로 설정되어야 한다.
- refresh_token
  - 필수(REQUIRED). 클라이언트에게 발급된 리프레시 토큰.
- scope
  - 선택(OPTIONAL). 3.3절에 설명된 액세스 요청의 범위. 요청된 범위는 리소스 소유자가 최초에 부여한 범위를 초과해서는 안 되며(MUST NOT), 이 값이 생략된 경우에는 리소스 소유자가 최초에 부여한 범위와 동일한 것으로 간주된다.

리프레시 토큰은 일반적으로 추가적인 액세스 토큰을 요청하기 위해 사용되는 장기간 유효한 자격 증명이므로, 리프레시 토큰은 그것이 발급된 클라이언트에 바인딩된다. 클라이언트 유형이 기밀 클라이언트이거나, 클라이언트 자격 증명이 발급되었거나(또는 다른 인증 요구 사항이 할당된 경우), 클라이언트는 3.2.1절에 설명된 바와 같이 인가 서버에 대해 반드시 인증을 수행해야 한다(MUST).

예를 들어, 클라이언트는 전송 계층 보안(transport-layer security)을 사용하여 다음과 같은 HTTP 요청을 보낸다(가독성을 위해 추가적인 줄 바꿈이 포함되어 있음):
```
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
```

인가 서버는 반드시 다음을 수행해야 한다(MUST):
- 기밀 클라이언트 또는 클라이언트 자격 증명이 발급된 모든 클라이언트(또는 다른 인증 요구 사항이 있는 클라이언트)에 대해 클라이언트 인증을 요구할 것,
- 클라이언트 인증이 포함된 경우 클라이언트를 인증하고, 리프레시 토큰이 인증된 클라이언트에게 발급된 것임을 보장할 것,
- 리프레시 토큰을 검증할 것.

검증이 유효하고 인가된 경우, 인가 서버는 5.1절에 설명된 바와 같이 액세스 토큰을 발급한다. 요청의 검증이 실패했거나 요청이 유효하지 않은 경우, 인가 서버는 5.2절에 설명된 오류 응답을 반환한다.

인가 서버는 새로운 리프레시 토큰을 발급할 수 있으며(MAY), 이 경우 클라이언트는 기존의 리프레시 토큰을 반드시 폐기하고(MUST) 새로 발급된 리프레시 토큰으로 교체해야 한다. 인가 서버는 클라이언트에게 새로운 리프레시 토큰을 발급한 이후 기존의 리프레시 토큰을 철회할 수 있다(MAY). 새로운 리프레시 토큰이 발급되는 경우, 해당 리프레시 토큰의 범위(scope)는 요청에 클라이언트가 포함한 리프레시 토큰의 범위와 반드시 동일해야 한다(MUST).

## 7. 보호된 리소스 접근
클라이언트는 액세스 토큰을 리소스 서버에 제시함으로써 보호된 리소스에 접근한다. 리소스 서버는 액세스 토큰을 반드시 검증해야 하며(MUST), 해당 토큰이 만료되지 않았는지, 그리고 그 범위(scope)가 요청된 리소스를 포괄하는지를 확인해야 한다. 리소스 서버가 액세스 토큰을 검증하는 데 사용하는 방법(및 오류 응답)은 본 명세의 범위를 벗어나지만, 일반적으로는 리소스 서버와 인가 서버 간의 상호작용 또는 협력을 수반한다.

클라이언트가 리소스 서버와 인증하기 위해 액세스 토큰을 사용하는 방식은 인가 서버가 발급한 액세스 토큰의 유형에 따라 달라진다. 일반적으로는 [RFC2617]에 정의된 HTTP "Authorization" 요청 헤더 필드를 사용하며, [RFC6750]과 같이 사용된 액세스 토큰 유형의 명세에서 정의된 인증 스킴을 따른다.

### 7.1 액세스 토큰 유형
액세스 토큰 유형은 (유형별 속성과 함께) 보호된 리소스 요청을 성공적으로 수행하기 위해 액세스 토큰을 사용하는 데 필요한 정보를 클라이언트에게 제공한다. 클라이언트는 토큰 유형을 이해하지 못하는 경우 해당 액세스 토큰을 사용해서는 안 된다(MUST NOT).

예를 들어, [RFC6750]에 정의된 "bearer" 토큰 유형은 요청에 액세스 토큰 문자열을 단순히 포함하는 방식으로 사용된다:
```
GET /resource/1 HTTP/1.1
Host: example.com
Authorization: Bearer mF_9.B5f-4.1JqM
```

반면, [OAuth-HTTP-MAC]에 정의된 "mac" 토큰 유형은 액세스 토큰과 함께 메시지 인증 코드(MAC) 키를 발급하여, HTTP 요청의 특정 구성 요소에 서명하는 데 사용된다:
```
GET /resource/1 HTTP/1.1
Host: example.com
Authorization: MAC id="h480djs93hd8",
                   nonce="274312:dj83hs9s",
                   mac="kDZvddkndxvhGRXZhvuDjEWhGeE="
```
위의 예시들은 설명을 위한 목적일 뿐이다. 개발자는 사용에 앞서 [RFC6750] 및 [OAuth-HTTP-MAC] 명세를 참고하는 것이 권장된다.

각 액세스 토큰 유형 정의는 "access_token" 응답 매개변수와 함께 클라이언트에게 전달되는 추가 속성(있는 경우)을 명시한다. 또한 보호된 리소스 요청을 수행할 때 액세스 토큰을 포함하기 위해 사용되는 HTTP 인증 방식을 정의한다.

### 7.2 오류 응답
리소스 접근 요청이 실패한 경우, 리소스 서버는 클라이언트에게 오류를 알려야 한다(SHOULD). 이러한 오류 응답의 구체적인 내용은 본 명세의 범위를 벗어나지만, 본 문서는 OAuth 토큰 인증 스킴들 간에 공유될 오류 값들을 위해 11.4절에서 공통 레지스트리를 설정한다.

OAuth 토큰 인증을 주된 목적으로 설계된 새로운 인증 스킴은, 이 명세에 의해 설정된 오류 레지스트리에 등록된 오류 값들 중에서 허용되는 오류 값을 사용하여, 클라이언트에게 오류 상태 코드를 제공하는 메커니즘을 정의하는 것이 바람직하다(SHOULD).

이러한 스킴들은 유효한 오류 코드의 집합을 등록된 값들의 부분집합으로 제한할 수 있다(MAY). 오류 코드가 명명된 매개변수를 통해 반환되는 경우, 해당 매개변수 이름은 "error"여야 한다(SHOULD).

OAuth 토큰 인증에 사용될 수 있으나 그 목적을 주로 위해 설계되지 않은 다른 인증 스킴들 또한, 동일한 방식으로 자신의 오류 값들을 이 레지스트리에 바인딩할 수 있다(MAY).

새로운 인증 스킴들은 또한, 본 명세에서 사용되는 방식과 병행하여 오류 정보를 반환하기 위해 "error_description" 및 "error_uri" 매개변수의 사용을 명시하도록 선택할 수 있다(MAY).

## 8. 확장성
### 8.1 액세스 토큰 유형 정의
액세스 토큰 유형은 다음 두 가지 방법 중 하나로 정의될 수 있다:
11.1절에 명시된 절차에 따라 액세스 토큰 유형 레지스트리에 등록하거나, 또는 고유한 절대 URI를 이름으로 사용한다.

URI 이름을 사용하는 유형은, 일반적으로 널리 적용되지 않고 해당 리소스 서버의 구현 세부 사항에 특화된 벤더 전용 구현으로 제한되는 것이 바람직하다(SHOULD).

그 외의 모든 유형은 반드시 등록되어야 한다(MUST). 유형 이름은 type-name ABNF에 부합해야 한다. 유형 정의에 새로운 HTTP 인증 스킴이 포함되는 경우, 해당 유형 이름은 [RFC2617]에 정의된 HTTP 인증 스킴 이름과 동일한 것이 바람직하다(SHOULD). "example" 토큰 유형은 예제에서 사용하기 위해 예약되어 있다.
```
type-name  = 1*name-char
name-char = "-" / "." / "_" / DIGIT / ALPHA
```

### 8.2 새로운 엔드포인트 매개변수 정의
인가 엔드포인트 또는 토큰 엔드포인트와 함께 사용하기 위한 새로운 요청 또는 응답 매개변수는, 11.2절에 명시된 절차에 따라 OAuth 매개변수 레지스트리(OAuth Parameters registry) 에 정의되고 등록된다.

매개변수 이름은 반드시 param-name ABNF에 부합해야 하며(MUST), 매개변수 값의 구문 또한 반드시 명확하게 정의되어야 한다(MUST)(예: ABNF를 사용하거나, 기존 매개변수의 구문에 대한 참조를 사용하는 방식).
```
param-name = 1*name-char
name-char  = "-" / "." / "_" / DIGIT / ALPHA
```
일반적으로 널리 적용되지 않고, 사용되는 인가 서버의 구현 세부 사항에 특화된 등록되지 않은 벤더 전용 매개변수 확장은, 다른 등록된 값들과 충돌할 가능성이 낮은 벤더 전용 접두어를 사용하는 것이 바람직하다(SHOULD)(예: 'companyname_'로 시작).

### 8.3 새로운 인가 그랜트 유형 정의
새로운 인가 그랜트 유형은 "grant_type" 매개변수와 함께 사용하기 위해 고유한 절대 URI를 할당함으로써 정의될 수 있다. 확장된 그랜트 유형이 토큰 엔드포인트에 대한 추가 매개변수를 요구하는 경우, 해당 매개변수들은 11.2절에 설명된 바와 같이 OAuth 매개변수 레지스트리에 반드시 등록되어야 한다(MUST).

### 8.4 새로운 인가 엔드포인트 응답 유형 정의
인가 엔드포인트와 함께 사용하기 위한 새로운 응답 유형은 11.3절에 명시된 절차에 따라 인가 엔드포인트 응답 유형 레지스트리(Authorization Endpoint Response Types registry) 에 정의되고 등록된다. 응답 유형 이름은 반드시 response-type ABNF에 부합해야 한다(MUST).
```
response-type  = response-name *( SP response-name )
response-name  = 1*response-char
response-char  = "_" / DIGIT / ALPHA
```

응답 유형에 하나 이상의 공백 문자(%x20)가 포함된 경우, 이는 값의 순서가 중요하지 않은 공백으로 구분된 값 목록으로 비교된다. 동일한 값 집합에 대해서는 하나의 값 순서만 등록될 수 있으며, 이는 동일한 값 집합의 다른 모든 배열을 포괄한다.

예를 들어, "token code" 응답 유형은 본 명세에서 정의되지 않는다. 그러나 확장은 "token code" 응답 유형을 정의하고 등록할 수 있다. 일단 등록되면 동일한 조합을 "code token"으로 등록할 수는 없지만, 두 값 모두 동일한 응답 유형을 나타내는 데 사용할 수 있다.

### 8.5 추가 오류 코드 정의
프로토콜 확장(즉, 액세스 토큰 유형, 확장 매개변수 또는 확장 그랜트 유형)이 인가 코드 그랜트 오류 응답(4.1.2.1절), 암묵적 그랜트 오류 응답(4.2.2.1절), 토큰 오류 응답(5.2절) 또는 리소스 접근 오류 응답(7.2절)과 함께 사용하기 위한 추가 오류 코드를 요구하는 경우, 이러한 오류 코드는 정의될 수 있다(MAY).

확장 오류 코드는, 함께 사용되는 확장이 등록된 액세스 토큰 유형이거나, 등록된 엔드포인트 매개변수이거나, 또는 확장 그랜트 유형인 경우, 11.4절에 명시된 절차에 따라 반드시 등록되어야 한다(MUST). 등록되지 않은 확장과 함께 사용되는 오류 코드는 등록될 수 있다(MAY).

오류 코드는 반드시 error ABNF에 부합해야 하며, 가능한 경우 식별 가능한 이름 접두어를 포함하는 것이 바람직하다(SHOULD). 예를 들어, 확장 매개변수 "example"에 설정된 값이 유효하지 않음을 식별하는 오류는 "example_invalid"로 명명하는 것이 바람직하다.
```
error      = 1*error-char
error-char = %x20-21 / %x23-5B / %x5D-7E
```

## 9. 네이티브 애플리케이션
네이티브 애플리케이션은 리소스 소유자가 사용하는 장치에 설치되고 실행되는 클라이언트(즉, 데스크톱 애플리케이션, 네이티브 모바일 애플리케이션)를 의미한다. 네이티브 애플리케이션은 보안, 플랫폼 기능, 그리고 전반적인 최종 사용자 경험과 관련하여 특별한 고려가 필요하다.

인가 엔드포인트는 클라이언트와 리소스 소유자의 사용자 에이전트 간의 상호작용을 요구한다. 네이티브 애플리케이션은 외부 사용자 에이전트를 호출하거나, 애플리케이션 내부에 사용자 에이전트를 임베드할 수 있다. 예를 들면 다음과 같다:

- 외부 사용자 에이전트(External user-agent)
  - 네이티브 애플리케이션은 운영체제에 등록된 스킴을 가진 리다이렉션 URI를 사용하여 클라이언트를 처리자로 호출함으로써 인가 서버의 응답을 수신할 수 있다. 또한 자격 증명의 수동 복사-붙여넣기, 로컬 웹 서버 실행, 사용자 에이전트 확장 설치, 또는 클라이언트가 제어하는 서버에 호스팅된 리소스를 식별하는 리다이렉션 URI를 제공하고, 해당 서버가 다시 네이티브 애플리케이션이 사용할 수 있도록 응답을 전달하는 방식도 사용할 수 있다.
- 임베디드 사용자 에이전트(Embedded user-agent)
  - 네이티브 애플리케이션은 리소스 로딩 중에 발생하는 상태 변화를 모니터링하거나, 사용자 에이전트의 쿠키 저장소에 접근함으로써, 임베디드된 사용자 에이전트와 직접 통신하여 응답을 획득한다.


외부 사용자 에이전트와 임베디드 사용자 에이전트 중 하나를 선택할 때, 개발자는 다음 사항들을 고려해야 한다:
- 외부 사용자 에이전트는 리소스 소유자가 이미 인가 서버에 대해 활성 세션을 가지고 있을 수 있으므로, 재인증이 필요 없어 완료율을 향상시킬 수 있다. 또한 익숙한 최종 사용자 경험과 기능을 제공한다. 리소스 소유자는 인증을 보조하기 위해 사용자 에이전트의 기능이나 확장(예: 비밀번호 관리자, 2단계 인증 장치 판독기)에 의존할 수도 있다.
- 임베디드 사용자 에이전트는 컨텍스트를 전환하거나 새로운 창을 열 필요가 없으므로 사용성을 향상시킬 수 있다.
- 임베디드 사용자 에이전트는 보안상 도전을 야기하는데, 이는 리소스 소유자가 대부분의 외부 사용자 에이전트에서 제공되는 시각적 보호 장치에 접근할 수 없는, 식별되지 않은 창에서 인증을 수행하기 때문이다. 임베디드 사용자 에이전트는 최종 사용자가 식별되지 않은 인증 요청을 신뢰하도록 학습시키며, 이는 피싱 공격을 더 쉽게 실행할 수 있게 만든다.

암묵적 그랜트 유형과 인가 코드 그랜트 유형 중 하나를 선택할 때는 다음 사항들을 고려해야 한다:
- 인가 코드 그랜트 유형을 사용하는 네이티브 애플리케이션은, 네이티브 애플리케이션이 클라이언트 자격 증명을 기밀로 유지할 수 없기 때문에, 클라이언트 자격 증명을 사용하지 않고 이를 사용하는 것이 바람직하다(SHOULD).
- 암묵적 그랜트 유형 흐름을 사용하는 경우, 리프레시 토큰이 반환되지 않으므로, 액세스 토큰이 만료되면 인가 과정을 다시 반복해야 한다.

## 10. 보안 고려 사항
유연하고 확장 가능한 프레임워크로서, OAuth의 보안 고려 사항은 많은 요소들에 따라 달라진다. 다음 절들은 2.1절에서 설명된 세 가지 클라이언트 프로파일, 즉 웹 애플리케이션, 사용자 에이전트 기반 애플리케이션, 그리고 네이티브 애플리케이션에 초점을 맞춘 보안 지침을 구현자에게 제공한다.

OAuth의 포괄적인 보안 모델과 분석, 그리고 프로토콜 설계에 대한 배경은 [OAuth-THREATMODEL]에 제시되어 있다.

### 10.1 클라이언트 인증
인가 서버는 클라이언트 인증을 목적으로 웹 애플리케이션 클라이언트에 대해 클라이언트 자격 증명을 설정한다. 인가 서버는 클라이언트 비밀번호보다 더 강력한 클라이언트 인증 수단을 고려하는 것이 바람직하다(encouraged). 웹 애플리케이션 클라이언트는 클라이언트 비밀번호 및 기타 클라이언트 자격 증명의 기밀성을 반드시 보장해야 한다(MUST).

인가 서버는 클라이언트 인증을 목적으로 네이티브 애플리케이션 또는 사용자 에이전트 기반 애플리케이션 클라이언트에 클라이언트 비밀번호나 기타 클라이언트 자격 증명을 발급해서는 안 된다(MUST NOT). 다만, 인가 서버는 특정 장치에 설치된 특정 네이티브 애플리케이션 클라이언트의 개별 설치에 한해서는 클라이언트 비밀번호 또는 기타 자격 증명을 발급할 수 있다(MAY).

클라이언트 인증이 불가능한 경우, 인가 서버는 클라이언트의 신원을 검증하기 위해 다른 수단을 사용하는 것이 바람직하다(SHOULD). 예를 들어, 클라이언트 리다이렉션 URI의 등록을 요구하거나, 리소스 소유자가 신원을 확인하도록 요청하는 방법이 있다. 유효한 리다이렉션 URI는 리소스 소유자의 인가를 요청하는 단계에서 클라이언트의 신원을 검증하기에는 충분하지 않지만, 리소스 소유자의 인가를 획득한 이후 자격 증명이 위조된 클라이언트에게 전달되는 것을 방지하는 데에는 사용할 수 있다.

인가 서버는 인증되지 않은 클라이언트와 상호작용하는 데 따른 보안 영향을 고려해야 하며, 이러한 클라이언트에게 발급되는 기타 자격 증명(예: 리프레시 토큰)의 잠재적인 노출을 제한하기 위한 조치를 취해야 한다.

### 10.2 클라이언트 사칭
악의적인 클라이언트는, 사칭 대상이 되는 클라이언트가 자신의 클라이언트 자격 증명을 기밀로 유지하지 못하거나 유지할 수 없는 경우, 다른 클라이언트를 사칭하여 보호된 리소스에 대한 접근을 획득할 수 있다.

인가 서버는 가능한 경우 항상 클라이언트를 인증해야 한다(MUST). 클라이언트의 특성상 인가 서버가 클라이언트를 인증할 수 없는 경우, 인가 서버는 인가 응답을 수신하기 위해 사용되는 모든 리다이렉션 URI의 등록을 반드시 요구해야 하며(MUST), 이러한 잠재적으로 악의적인 클라이언트로부터 리소스 소유자를 보호하기 위해 다른 수단을 사용하는 것이 바람직하다(SHOULD). 예를 들어, 인가 서버는 클라이언트와 그 출처를 식별하는 데 리소스 소유자가 도움을 줄 수 있도록 개입시킬 수 있다.

인가 서버는 리소스 소유자의 명시적인 인증을 강제하고, 클라이언트와 요청된 인가 범위(scope) 및 수명(lifetime)에 대한 정보를 리소스 소유자에게 제공하는 것이 바람직하다(SHOULD). 리소스 소유자는 현재 클라이언트의 맥락에서 해당 정보를 검토한 후, 요청을 승인하거나 거부할 책임이 있다.

인가 서버는 클라이언트를 인증하지 않거나, 반복된 요청이 사칭자가 아닌 원래의 클라이언트로부터 온 것임을 보장하는 다른 수단에 의존하지 않는 한, 리소스 소유자의 적극적인 상호작용 없이 반복적인 인가 요청을 자동으로 처리해서는 안 된다(SHOULD NOT).

### 10.3 액세스 토큰
액세스 토큰 자격 증명(및 모든 기밀 액세스 토큰 속성)은 전송 중과 저장 시에 반드시 기밀로 유지되어야 하며(MUST), 인가 서버, 해당 액세스 토큰이 유효한 리소스 서버들, 그리고 해당 액세스 토큰이 발급된 클라이언트 사이에서만 공유되어야 한다. 액세스 토큰 자격 증명은 1.6절에 설명된 바와 같이 [RFC2818]에 정의된 서버 인증을 사용하는 TLS를 통해서만 전송되어야 한다(MUST).

암묵적 그랜트 유형을 사용하는 경우, 액세스 토큰은 URI 프래그먼트(fragment)에 포함되어 전송되며, 이는 인가되지 않은 당사자에게 노출될 수 있다.

인가 서버는 인가되지 않은 당사자가 유효한 액세스 토큰을 생성, 수정, 또는 추측할 수 없도록 반드시 보장해야 한다(MUST).

클라이언트는 필요한 최소한의 범위(scope)로 액세스 토큰을 요청하는 것이 바람직하다(SHOULD). 인가 서버는 요청된 범위를 어떻게 허용할지 결정할 때 클라이언트의 신원을 고려하는 것이 바람직하며(SHOULD), 요청된 것보다 더 적은 권한을 가진 액세스 토큰을 발급할 수도 있다(MAY).

본 명세는 리소스 서버가 특정 클라이언트에 의해 제시된 액세스 토큰이 인가 서버에 의해 해당 클라이언트에게 발급된 것인지를 보장하기 위한 어떠한 방법도 제공하지 않는다.

### 10.4 리프레시 토큰
인가 서버는 웹 애플리케이션 클라이언트와 네이티브 애플리케이션 클라이언트에 대해 리프레시 토큰을 발급할 수 있다(MAY).

리프레시 토큰은 전송 중과 저장 시에 반드시 기밀로 유지되어야 하며(MUST), 인가 서버와 해당 리프레시 토큰이 발급된 클라이언트 사이에서만 공유되어야 한다. 인가 서버는 리프레시 토큰과 해당 토큰이 발급된 클라이언트 간의 바인딩을 반드시 유지해야 한다(MUST). 리프레시 토큰은 1.6절에 설명된 바와 같이 [RFC2818]에 정의된 서버 인증을 사용하는 TLS를 통해서만 전송되어야 한다(MUST).

클라이언트 신원을 인증할 수 있는 경우, 인가 서버는 리프레시 토큰과 클라이언트 신원 간의 바인딩을 반드시 검증해야 한다(MUST). 클라이언트 인증이 불가능한 경우, 인가 서버는 리프레시 토큰 오용을 탐지하기 위한 다른 수단을 배치하는 것이 바람직하다(SHOULD).

예를 들어, 인가 서버는 액세스 토큰을 갱신할 때마다 새로운 리프레시 토큰을 발급하는 리프레시 토큰 로테이션(refresh token rotation)을 사용할 수 있다. 이 경우 이전 리프레시 토큰은 무효화되지만, 인가 서버에 의해 보관된다. 만약 리프레시 토큰이 탈취되어 공격자와 정상적인 클라이언트 양쪽에서 사용된다면, 둘 중 하나는 이미 무효화된 리프레시 토큰을 제시하게 되며, 이를 통해 인가 서버는 침해 사실을 인지할 수 있다.

인가 서버는 인가되지 않은 당사자가 유효한 리프레시 토큰을 생성, 수정, 또는 추측할 수 없도록 반드시 보장해야 한다(MUST).

### 10.5 인가 코드
인가 코드의 전송은 보안 채널을 통해 이루어지는 것이 바람직하며(SHOULD), 리다이렉션 URI가 네트워크 리소스를 식별하는 경우 클라이언트는 해당 URI에 대해 TLS 사용을 요구하는 것이 바람직하다(SHOULD). 인가 코드는 사용자 에이전트 리다이렉션을 통해 전송되기 때문에, 사용자 에이전트의 방문 기록(history)이나 HTTP 리퍼러(referrer) 헤더를 통해 노출될 가능성이 있다.

인가 코드는 평문 베어러 자격 증명(plaintext bearer credentials)으로 동작하며, 인가 서버에서 인가를 부여한 리소스 소유자와, 그 절차를 완료하기 위해 클라이언트로 돌아오는 리소스 소유자가 동일한지 여부를 검증하는 데 사용된다. 따라서 클라이언트가 인가 코드를 자체적인 리소스 소유자 인증에 의존하는 경우, 클라이언트 리다이렉션 엔드포인트는 반드시 TLS 사용을 요구해야 한다(MUST).

인가 코드는 반드시 짧은 수명을 가져야 하며(MUST), 한 번만 사용 가능해야 한다(single-use). 인가 서버가 하나의 인가 코드를 액세스 토큰으로 교환하려는 여러 번의 시도를 관찰한 경우, 인가 서버는 해당 인가 코드가 침해되었다고 판단하여, 그 인가 코드를 기반으로 이미 발급된 모든 액세스 토큰을 철회하려고 시도하는 것이 바람직하다(SHOULD).

클라이언트를 인증할 수 있는 경우, 인가 서버는 반드시 클라이언트를 인증해야 하며(MUST), 해당 인가 코드가 동일한 클라이언트에게 발급된 것임을 보장해야 한다.

### 10.6 인가 코드 리다이렉션 URI 조작
인가 코드 그랜트 유형을 사용하여 인가를 요청할 때, 클라이언트는 "redirect_uri" 매개변수를 통해 리다이렉션 URI를 지정할 수 있다. 공격자가 이 리다이렉션 URI의 값을 조작할 수 있다면, 인가 서버가 리소스 소유자의 사용자 에이전트를 공격자가 제어하는 URI로 리다이렉션하도록 유도하여 인가 코드를 탈취할 수 있다.

공격자는 합법적인 클라이언트에 계정을 생성하고 인가 흐름을 시작할 수 있다. 공격자의 사용자 에이전트가 액세스 권한을 부여하기 위해 인가 서버로 전송될 때, 공격자는 합법적인 클라이언트가 제공한 인가 URI를 가로채어 클라이언트의 리다이렉션 URI를 공격자가 제어하는 URI로 교체한다. 이후 공격자는 피해자가 조작된 링크를 따라가 합법적인 클라이언트에 대한 접근 권한을 부여하도록 속인다.

인가 서버에 도달하면, 피해자는 합법적이고 신뢰할 수 있는 클라이언트를 대신한 정상적이고 유효한 요청을 보게 되며, 해당 요청을 승인한다. 그 결과 피해자는 인가 코드가 포함된 상태로 공격자가 제어하는 엔드포인트로 리다이렉션된다. 공격자는 이후 클라이언트가 원래 제공한 리다이렉션 URI를 사용하여 인가 코드를 클라이언트로 전송함으로써 인가 흐름을 완료한다. 클라이언트는 인가 코드를 액세스 토큰으로 교환하고 이를 공격자의 클라이언트 계정과 연결하게 되며, 그 결과 공격자는 (클라이언트를 통해) 피해자가 인가한 보호된 리소스에 접근할 수 있게 된다.

이러한 공격을 방지하기 위해, 인가 서버는 인가 코드를 획득할 때 사용된 리다이렉션 URI가 인가 코드를 액세스 토큰으로 교환할 때 제공되는 리다이렉션 URI와 동일함을 반드시 보장해야 한다(MUST). 인가 서버는 공개 클라이언트에 대해서는 반드시(MUST), 기밀 클라이언트에 대해서는 권장 사항으로(SHOULD) 리다이렉션 URI의 등록을 요구해야 한다. 요청에 리다이렉션 URI가 제공된 경우, 인가 서버는 반드시 이를 등록된 값과 대조하여 검증해야 한다(MUST).

### 10.7 리소스 소유자 비밀번호 자격 증명
리소스 소유자 비밀번호 자격 증명 그랜트 유형은 주로 레거시 시스템 지원이나 마이그레이션 목적을 위해 사용된다. 이 방식은 클라이언트가 사용자 이름과 비밀번호를 저장하는 데 따른 전반적인 위험을 줄여주기는 하지만, 여전히 높은 권한을 가진 자격 증명을 클라이언트에 노출해야 한다는 필요성을 제거하지는 못한다.

이 그랜트 유형은, 본 프로토콜이 지양하고자 하는 비밀번호 안티패턴(password anti-pattern)을 유지한다는 점에서, 다른 그랜트 유형들보다 더 높은 위험을 내포하고 있다. 클라이언트가 비밀번호를 악용할 수도 있고, 비밀번호가 의도치 않게 공격자에게 노출될 수도 있다(예: 클라이언트가 보관하는 로그 파일이나 기타 기록을 통해).

또한 리소스 소유자는 인가 과정에 대한 통제권을 가지지 못한다는 문제도 있다(리소스 소유자의 개입은 자격 증명을 클라이언트에 전달하는 시점에서 종료된다). 이로 인해 클라이언트는 리소스 소유자가 의도한 것보다 더 넓은 범위(scope)의 액세스 토큰을 획득할 수 있다. 인가 서버는 이 그랜트 유형을 통해 발급되는 액세스 토큰의 범위와 수명을 신중히 고려해야 한다.

인가 서버와 클라이언트는 이 그랜트 유형의 사용을 최소화하는 것이 바람직하며(SHOULD), 가능한 경우 다른 그랜트 유형들을 사용하는 것이 바람직하다.

### 10.8 요청 기밀성
액세스 토큰, 리프레시 토큰, 리소스 소유자 비밀번호, 그리고 클라이언트 자격 증명은 평문으로 전송되어서는 안 된다(MUST NOT). 인가 코드는 평문으로 전송되지 않는 것이 바람직하다(SHOULD NOT).

"state" 및 "scope" 매개변수에는 민감한 클라이언트 정보나 리소스 소유자 정보가 평문으로 포함되지 않는 것이 바람직하다(SHOULD NOT). 이는 이러한 매개변수들이 안전하지 않은 채널을 통해 전송되거나, 안전하지 않게 저장될 수 있기 때문이다.

### 10.9 엔드포인트 진위 보장
중간자 공격(man-in-the-middle attacks)을 방지하기 위해, 인가 서버는 인가 엔드포인트와 토큰 엔드포인트로 전송되는 모든 요청에 대해 [RFC2818]에 정의된 서버 인증을 사용하는 TLS의 사용을 반드시 요구해야 한다(MUST).

클라이언트는 [RFC6125]에 정의된 바와 같이, 그리고 서버 신원 인증에 대한 요구 사항에 부합하도록, 인가 서버의 TLS 인증서를 반드시 검증해야 한다(MUST).

### 10.10 자격 증명 추측 공격
인가 서버는 공격자가 액세스 토큰, 인가 코드, 리프레시 토큰, 리소스 소유자 비밀번호, 그리고 클라이언트 자격 증명을 추측하지 못하도록 반드시 방지해야 한다(MUST).

생성된 토큰(및 최종 사용자가 직접 다루도록 의도되지 않은 기타 자격 증명)을 공격자가 추측할 확률은 반드시 2^(-128) 이하이어야 하며(MUST), 2^(-160) 이하인 것이 바람직하다(SHOULD).

인가 서버는 최종 사용자가 사용하는 것을 목적으로 한 자격 증명에 대해서는, 이를 보호하기 위한 다른 수단을 반드시 사용해야 한다(MUST).

### 10.11 피싱 공격
이 프로토콜 및 유사한 프로토콜이 널리 배포되면, 최종 사용자들이 비밀번호를 입력하도록 요구하는 웹사이트로 리다이렉션되는 관행에 무감각해질 수 있다. 최종 사용자가 자격 증명을 입력하기 전에 이러한 웹사이트의 진위를 주의 깊게 확인하지 않는 경우, 공격자는 이러한 관행을 악용하여 리소스 소유자의 비밀번호를 탈취할 수 있게 된다.

서비스 제공자는 피싱 공격이 초래하는 위험에 대해 최종 사용자를 교육하려는 노력을 해야 하며, 최종 사용자가 자신의 사이트의 진위를 쉽게 확인할 수 있도록 하는 메커니즘을 제공해야 한다. 클라이언트 개발자는 사용자 에이전트와 상호작용하는 방식(예: 외부 사용자 에이전트, 임베디드 사용자 에이전트)과, 최종 사용자가 인가 서버의 진위를 검증할 수 있는 능력에 따른 보안 영향을 고려해야 한다.

피싱 공격의 위험을 줄이기 위해, 인가 서버는 최종 사용자와의 상호작용에 사용되는 모든 엔드포인트에 대해 TLS 사용을 반드시 요구해야 한다(MUST).

### 10.12 교차 사이트 요청 위조
교차 사이트 요청 위조(CSRF)는 공격자가 피해자 최종 사용자의 사용자 에이전트로 하여금, 신뢰하는 서버(일반적으로 유효한 세션 쿠키의 존재로 신뢰가 형성됨)를 향해 악의적인 URI를 따라가도록 만드는 공격이다(예: 오해를 유발하는 링크, 이미지, 또는 리다이렉션의 형태로 사용자 에이전트에 제공됨).

클라이언트의 리다이렉션 URI에 대한 CSRF 공격은 공격자가 자신의 인가 코드 또는 액세스 토큰을 주입할 수 있게 하며, 그 결과 클라이언트가 피해자의 보호된 리소스가 아닌 공격자의 보호된 리소스와 연관된 액세스 토큰을 사용하게 될 수 있다(예: 피해자의 은행 계좌 정보를 공격자가 제어하는 보호된 리소스에 저장하는 경우).

클라이언트는 자신의 리다이렉션 URI에 대해 CSRF 보호를 반드시 구현해야 한다(MUST). 이는 일반적으로 리다이렉션 URI 엔드포인트로 전송되는 모든 요청이, 해당 요청을 사용자 에이전트의 인증된 상태와 바인딩하는 값을 포함하도록 요구함으로써 달성된다(예: 사용자 에이전트를 인증하는 데 사용된 세션 쿠키의 해시). 클라이언트는 인가 요청을 수행할 때 이 값을 인가 서버로 전달하기 위해 “state” 요청 매개변수를 사용하는 것이 바람직하다(SHOULD).

최종 사용자로부터 인가가 획득되면, 인가 서버는 “state” 매개변수에 포함된 필수 바인딩 값을 함께 포함하여 최종 사용자의 사용자 에이전트를 다시 클라이언트로 리다이렉션한다. 이 바인딩 값은 클라이언트가 해당 값을 사용자 에이전트의 인증된 상태와 비교함으로써 요청의 유효성을 검증할 수 있도록 해준다. CSRF 보호를 위해 사용되는 바인딩 값은 반드시 추측 불가능한 값(10.10절에 설명된 바와 같음)을 포함해야 하며(MUST), 사용자 에이전트의 인증된 상태(예: 세션 쿠키, HTML5 로컬 스토리지)는 클라이언트와 사용자 에이전트만 접근할 수 있는 위치에 보관되어야 한다(즉, 동일 출처 정책에 의해 보호되어야 한다).

인가 서버의 인가 엔드포인트에 대한 CSRF 공격은, 공격자가 최종 사용자의 개입이나 인식 없이도 악의적인 클라이언트에 대해 최종 사용자 인가를 획득하게 만들 수 있다.

인가 서버는 자신의 인가 엔드포인트에 대해 CSRF 보호를 반드시 구현해야 하며(MUST), 악의적인 클라이언트가 리소스 소유자의 인지와 명시적인 동의 없이 인가를 획득할 수 없도록 보장해야 한다.

### 10.13 클릭재킹
클릭재킹 공격에서, 공격자는 정상적인 클라이언트를 등록한 후, 인가 서버의 인가 엔드포인트 웹 페이지를 투명한 iframe으로 로드하여 더미 버튼 세트 위에 겹쳐 놓은 악의적인 사이트를 구성한다. 이 더미 버튼들은 인가 페이지의 중요한 버튼 바로 아래에 정확히 위치하도록 정교하게 배치된다. 최종 사용자가 오해를 유발하는 보이는 버튼을 클릭하면, 실제로는 인가 페이지의 보이지 않는 버튼(예: “Authorize” 버튼)을 클릭하게 된다. 이로 인해 공격자는 최종 사용자의 인지 없이 리소스 소유자가 자신의 클라이언트에 대한 접근을 승인하도록 속일 수 있다.

이러한 형태의 공격을 방지하기 위해, 네이티브 애플리케이션은 최종 사용자 인가를 요청할 때 애플리케이션 내부에 브라우저를 임베드하는 대신 외부 브라우저를 사용하는 것이 바람직하다(SHOULD). 대부분의 최신 브라우저에서는, 인가 서버가 (비표준인) “x-frame-options” 헤더를 사용하여 iframe 사용을 차단할 수 있다. 이 헤더는 “deny”와 “sameorigin” 두 가지 값을 가질 수 있으며, 각각 모든 프레이밍을 차단하거나, 다른 출처(origin)의 사이트에 의한 프레이밍을 차단한다. 구형 브라우저의 경우, JavaScript 기반의 프레임 차단(frame-busting) 기법을 사용할 수 있으나, 모든 브라우저에서 효과적이지 않을 수 있다.

### 10.14 코드 주입 및 입력 검증
코드 주입 공격은 입력 값이나 기타 외부 변수가 애플리케이션에서 정제(sanitize)되지 않은 채 사용되어 애플리케이션 로직이 변경되는 경우에 발생한다. 이는 공격자가 애플리케이션 장치나 그 데이터에 접근하거나, 서비스 거부를 유발하거나, 광범위한 악의적 부작용을 초래하도록 만들 수 있다.

인가 서버와 클라이언트는 수신한 모든 값을 반드시 정제해야 하며(MUST), 가능한 경우 검증도 수행해야 한다. 특히 “state” 및 “redirect_uri” 매개변수의 값에 대해 그러해야 한다.

### 10.15 오픈 리다이렉터
인가 서버, 인가 엔드포인트, 그리고 클라이언트 리다이렉션 엔드포인트는 잘못 구성될 경우 오픈 리다이렉터로 동작할 수 있다. 오픈 리다이렉터란, 매개변수 값을 검증하지 않은 채 그 값에 지정된 위치로 사용자 에이전트를 자동으로 리다이렉션하는 엔드포인트를 의미한다.

오픈 리다이렉터는 피싱 공격에 사용될 수 있으며, 공격자가 익숙하고 신뢰받는 목적지의 URI 권한(authority) 구성 요소를 이용하여 최종 사용자를 악성 사이트로 방문하도록 유도하는 데에도 사용될 수 있다. 또한, 인가 서버가 클라이언트에게 리다이렉션 URI의 일부만 등록하도록 허용하는 경우, 공격자는 클라이언트가 운영하는 오픈 리다이렉터를 이용해 인가 서버의 검증은 통과하지만 인가 코드나 액세스 토큰을 공격자가 제어하는 엔드포인트로 전달하는 리다이렉션 URI를 구성할 수 있다.

### 10.16 암묵적 흐름에서 액세스 토큰을 사용한 리소스 소유자 가장
암묵적 흐름을 사용하는 공개 클라이언트의 경우, 본 명세는 액세스 토큰이 어떤 클라이언트에 발급되었는지를 클라이언트가 판단할 수 있는 방법을 제공하지 않는다.

리소스 소유자는 피싱이나 기타 명분으로 인해 공격자의 악성 클라이언트에 액세스 토큰을 부여함으로써 자원에 대한 접근을 자발적으로 위임할 수 있다. 공격자는 또한 다른 메커니즘을 통해 토큰을 탈취할 수도 있다. 이후 공격자는 해당 액세스 토큰을 정상적인 공개 클라이언트에 제공함으로써 리소스 소유자를 가장하려 시도할 수 있다.

암묵적 흐름(response_type=token)에서는, 공격자가 인가 서버의 응답에서 토큰을 쉽게 바꿔치기할 수 있으며, 실제 액세스 토큰을 이전에 공격자에게 발급된 토큰으로 대체할 수 있다.

클라이언트의 사용자를 식별하기 위해 백 채널(back channel)을 통해 전달되는 액세스 토큰에 의존하는 네이티브 애플리케이션과 통신하는 서버 또한, 공격자가 임의로 탈취한 액세스 토큰을 주입할 수 있는 손상된 애플리케이션을 생성함으로써 유사하게 공격받을 수 있다.

리소스에 대해 유효한 액세스 토큰을 제시할 수 있는 주체가 오직 리소스 소유자뿐이라고 가정하는 모든 공개 클라이언트는 이러한 유형의 공격에 취약하다.

이러한 공격은 정상적인 클라이언트에 있는 리소스 소유자의 정보를 공격자(악성 클라이언트)에게 노출시킬 수 있다. 또한 공격자는 원래 액세스 토큰이나 인가 코드를 부여한 리소스 소유자와 동일한 권한으로 정상적인 클라이언트에서 작업을 수행할 수 있게 된다.

리소스 소유자를 클라이언트에 인증하는 것은 본 명세의 범위를 벗어난다. 인가 과정을 클라이언트에 대한 위임된 최종 사용자 인증 형태로 사용하는 모든 명세(예: 서드파티 로그인 서비스)는, 액세스 토큰이 해당 클라이언트 사용을 위해 발급되었는지를 판단할 수 있게 하는 추가적인 보안 메커니즘(예: 액세스 토큰의 audience 제한) 없이 암묵적 흐름을 사용해서는 안 된다(MUST NOT).

## 11. IANA 고려 사항
### 11.1 액세스 토큰 유형 레지스트리
(OAuth Access Token Types Registry)

본 명세는 OAuth 액세스 토큰 유형 레지스트리를 설정한다.

액세스 토큰 유형은, 지정된 전문가(Designated Expert) 한 명 이상이 조언하는 가운데, oauth-ext-review@ietf.org 메일링 리스트에서 2주간의 검토 기간을 거친 후 Specification Required 정책([RFC5226])에 따라 등록된다.

다만, 명세가 출판되기 전에 값 할당이 가능하도록 하기 위해, 지정된 전문가가 해당 명세가 출판될 것이라고 충분히 만족하는 경우 출판 이전이라도 등록을 승인할 수 있다.

등록 요청은 적절한 제목(예: "Request for access token type: example")과 함께 oauth-ext-review@ietf.org 메일링 리스트로 보내져 검토 및 의견 수렴을 거쳐야 한다.

검토 기간 동안, 지정된 전문가(들)는 등록 요청을 승인하거나 거부하며, 그 결정 사항을 검토 메일링 리스트와 IANA에 전달한다. 거부 시에는 그 사유를 설명해야 하며, 가능한 경우 요청을 성공적으로 만들기 위한 개선 제안을 포함해야 한다.

IANA는 지정된 전문가(들)로부터 전달된 레지스트리 업데이트만 수락해야 하며, 모든 등록 요청은 검토 메일링 리스트로 안내해야 한다.

#### 11.1.1 등록 템플릿
- Type name:
  - 요청하는 이름 (예: "example")
- Additional Token Endpoint Response Parameters:
  - "access_token" 매개변수와 함께 반환되는 추가 응답 매개변수들. 새로운 매개변수는 반드시 11.2절에 설명된 OAuth 매개변수 레지스트리에 별도로 등록되어야 한다(MUST).
- HTTP Authentication Scheme(s):
  - 해당 토큰 유형의 액세스 토큰을 사용하여 보호된 리소스 요청을 인증할 때 사용되는 HTTP 인증 스킴 이름(있는 경우).
- Change controller:
  - 표준 트랙 RFC의 경우 "IETF"라고 명시한다. 그 외의 경우에는 책임 주체의 이름을 기재한다. 추가 정보(예: 우편 주소, 이메일 주소, 홈페이지 URI 등)를 포함할 수도 있다.
- Specification document(s):
  - 해당 매개변수를 정의하는 문서에 대한 참조. 가능한 경우 문서를 조회할 수 있는 URI를 포함하는 것이 바람직하다. 관련 절(section)을 명시할 수도 있으나 필수는 아니다.

### 11.2 OAuth 매개변수 레지스트리
(OAuth Parameters Registry)

본 명세는 OAuth 매개변수 레지스트리를 설정한다.

인가 엔드포인트 요청, 인가 엔드포인트 응답, 토큰 엔드포인트 요청, 또는 토큰 엔드포인트 응답에 포함되기 위한 추가 매개변수들은, 지정된 전문가(Designated Expert) 한 명 이상이 조언하는 가운데, oauth-ext-review@ietf.org 메일링 리스트에서 2주간의 검토 기간을 거친 후 Specification Required 정책([RFC5226])에 따라 등록된다. 다만, 명세가 출판되기 전에 값 할당이 가능하도록 하기 위해, 지정된 전문가가 해당 명세가 출판될 것이라고 충분히 만족하는 경우 출판 이전이라도 등록을 승인할 수 있다.

등록 요청은 적절한 제목(예: "Request for parameter: example")과 함께 oauth-ext-review@ietf.org 메일링 리스트로 보내져 검토 및 의견 수렴을 거쳐야 한다.

검토 기간 동안, 지정된 전문가(들)는 등록 요청을 승인하거나 거부하며, 그 결정 사항을 검토 메일링 리스트와 IANA에 전달한다. 거부 시에는 그 사유를 설명해야 하며, 가능한 경우 요청을 성공적으로 만들기 위한 개선 제안을 포함해야 한다.

IANA는 지정된 전문가(들)로부터 전달된 레지스트리 업데이트만 수락해야 하며, 모든 등록 요청은 검토 메일링 리스트로 안내해야 한다.

#### 11.2.1 등록 템플릿
- Parameter name:
  - 요청하는 매개변수 이름 (예: "example")
- Parameter usage location:
  - 해당 매개변수가 사용될 수 있는 위치. 가능한 위치는 다음과 같다: 인가 요청(authorization request), 인가 응답(authorization response), 토큰 요청(token request), 또는 토큰 응답(token response)
- Change controller:
  - 표준 트랙 RFC의 경우 "IETF"라고 명시한다. 그 외의 경우에는 책임 주체의 이름을 기재한다. 추가 정보(예: 우편 주소, 이메일 주소, 홈페이지 URI 등)를 포함할 수도 있다.
- Specification document(s):
  - 해당 매개변수를 정의하는 문서에 대한 참조. 가능한 경우 문서를 조회할 수 있는 URI를 포함하는 것이 바람직하다. 관련 절(section)을 명시할 수도 있으나 필수는 아니다.

#### 11.2.2 초기 레지스트리 내용
(Initial Registry Contents)

OAuth 매개변수 레지스트리의 초기 내용은 다음과 같다:
- 매개변수 이름: client_id
  - 사용 위치: 인가 요청, 토큰 요청
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: client_secret
  - 사용 위치: 토큰 요청
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: response_type
  - 사용 위치: 인가 요청
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: redirect_uri
  - 사용 위치: 인가 요청, 토큰 요청
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: scope
  - 사용 위치: 인가 요청, 인가 응답, 토큰 요청, 토큰 응답
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: state
  - 사용 위치: 인가 요청, 인가 응답
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: code
  - 사용 위치: 인가 응답, 토큰 요청
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: error_description
  - 사용 위치: 인가 응답, 토큰 응답
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: error_uri
  - 사용 위치: 인가 응답, 토큰 응답
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: grant_type
  - 사용 위치: 토큰 요청
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: access_token
  - 사용 위치: 인가 응답, 토큰 응답
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: token_type
  - 사용 위치: 인가 응답, 토큰 응답
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: expires_in
  - 사용 위치: 인가 응답, 토큰 응답
  - 변경 관리 주체: IETF=
  - 명세 문서: RFC 6749
- 매개변수 이름: username
  - 사용 위치: 토큰 요청
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: password
  - 사용 위치: 토큰 요청
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 매개변수 이름: refresh_token
  - 사용 위치: 토큰 요청, 토큰 응답
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749

### 11.3 OAuth 인가 엔드포인트 응답 유형 레지스트리
(OAuth Authorization Endpoint Response Types Registry)

본 명세는 OAuth 인가 엔드포인트 응답 유형 레지스트리를 설정한다.

인가 엔드포인트와 함께 사용하기 위한 추가 응답 유형은, 지정된 전문가(Designated Expert) 한 명 이상이 조언하는 가운데, oauth-ext-review@ietf.org 메일링 리스트에서 2주간의 검토 기간을 거친 후 Specification Required 정책([RFC5226])에 따라 등록된다. 다만, 명세가 출판되기 전에 값 할당이 가능하도록 하기 위해, 지정된 전문가(들)가 해당 명세가 출판될 것이라고 충분히 만족하는 경우 출판 이전이라도 등록을 승인할 수 있다.

등록 요청은 적절한 제목(예: "Request for response type: example")과 함께 oauth-ext-review@ietf.org 메일링 리스트로 보내져 검토 및 의견 수렴을 거쳐야 한다.

검토 기간 동안, 지정된 전문가(들)는 등록 요청을 승인하거나 거부하며, 그 결정 사항을 검토 메일링 리스트와 IANA에 전달한다. 거부 시에는 그 사유를 설명해야 하며, 가능한 경우 요청을 성공적으로 만들기 위한 개선 제안을 포함해야 한다.

IANA는 지정된 전문가(들)로부터 전달된 레지스트리 업데이트만 수락해야 하며, 모든 등록 요청은 검토 메일링 리스트로 안내해야 한다.

#### 11.3.1 등록 템플릿
- Response type name:
  - 요청하는 응답 유형 이름 (예: "example")
- Change controller:
  - 표준 트랙 RFC의 경우 "IETF"라고 명시한다. 그 외의 경우에는 책임 주체의 이름을 기재한다. 추가 정보(예: 우편 주소, 이메일 주소, 홈페이지 URI 등)를 포함할 수도 있다.
- Specification document(s):
  - 해당 응답 유형을 정의하는 문서에 대한 참조. 가능한 경우 문서를 조회할 수 있는 URI를 포함하는 것이 바람직하다. 관련 절(section)을 명시할 수도 있으나 필수는 아니다.

#### 11.3.2 초기 레지스트리 내용
(Initial Registry Contents)

OAuth 인가 엔드포인트 응답 유형 레지스트리의 초기 내용은 다음과 같다:
- 응답 유형 이름: code
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749
- 응답 유형 이름: token
  - 변경 관리 주체: IETF
  - 명세 문서: RFC 6749

### 11.4 OAuth 확장 오류 레지스트리
(OAuth Extensions Error Registry)

본 명세는 **OAuth 확장 오류 레지스트리(OAuth Extensions Error registry)**를 설정한다.

다른 프로토콜 확장(즉, 확장 그랜트 유형, 액세스 토큰 유형, 또는 확장 매개변수)과 함께 사용되는 추가 오류 코드는, 하나 이상의 지정된 전문가(Designated Expert)의 조언에 따라, oauth-ext-review@ietf.org 메일링 리스트에서 2주간의 검토 기간을 거친 후 Specification Required 정책([RFC5226])에 따라 등록된다. 다만, 명세가 출판되기 전에 값 할당이 가능하도록 하기 위해, 지정된 전문가(들)가 해당 명세가 출판될 것이라고 충분히 만족하는 경우 출판 이전이라도 등록을 승인할 수 있다.

등록 요청은 적절한 제목(예: "Request for error code: example")과 함께 oauth-ext-review@ietf.org 메일링 리스트로 보내져 검토 및 의견 수렴을 거쳐야 한다.

검토 기간 동안, 지정된 전문가(들)는 등록 요청을 승인하거나 거부하며, 그 결정 사항을 검토 메일링 리스트와 IANA에 전달한다. 거부 시에는 그 사유를 설명해야 하며, 가능한 경우 요청을 성공적으로 만들기 위한 제안을 포함해야 한다.

IANA는 지정된 전문가(들)로부터 전달된 레지스트리 업데이트만 수락해야 하며, 모든 등록 요청은 검토 메일링 리스트로 안내해야 한다.

#### 11.4.1 등록 템플릿
(Registration Template)

- Error name:
  - 요청하는 오류 이름 (예: "example").
  - 오류 이름의 값에는 %x20-21 / %x23-5B / %x5D-7E 집합에 포함되지 않은 문자가 포함되어서는 안 된다(MUST NOT).

- Error usage location: 오류가 사용될 수 있는 위치. 가능한 위치는 다음과 같다:
  - 인가 코드 그랜트 오류 응답 (4.1.2.1절)
  - 암묵적 그랜트 오류 응답 (4.2.2.1절)
  - 토큰 오류 응답 (5.2절)
  - 리소스 접근 오류 응답 (7.2절)

- Related protocol extension:
  - 해당 오류 코드가 함께 사용되는 확장 그랜트 유형, 액세스 토큰 유형, 또는 확장 매개변수의 이름.

- Change controller:
  - 표준 트랙 RFC의 경우 "IETF"라고 명시한다. 그 외의 경우에는 책임 주체의 이름을 기재한다. 추가 정보(예: 우편 주소, 이메일 주소, 홈페이지 URI 등)를 포함할 수도 있다.

- Specification document(s):
  - 해당 오류 코드를 정의하는 문서에 대한 참조. 가능한 경우 문서를 조회할 수 있는 URI를 포함하는 것이 바람직하다. 관련 절(section)을 명시할 수도 있으나 필수는 아니다.

## 12. 참고 문헌

### 12.1 규범적 참고 문헌
(Normative References)

[RFC2119]
- Bradner, S.,
- 「RFC에서 요구 수준을 나타내기 위해 사용하는 핵심 단어」,
- BCP 14, RFC 2119, 1997년 3월.

[RFC2246]
- Dierks, T. 및 C. Allen,
- 「TLS 프로토콜 버전 1.0」,
- RFC 2246, 1999년 1월.

[RFC2616]
- Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P.,
- 및 T. Berners-Lee,
- 「하이퍼텍스트 전송 프로토콜 — HTTP/1.1」,
- RFC 2616, 1999년 6월.

[RFC2617]
- Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P.,
- Luotonen, A., 및 L. Stewart,
- 「HTTP 인증: Basic 및 Digest 접근 인증」,
- RFC 2617, 1999년 6월.

[RFC2818]
- Rescorla, E.,
- 「TLS 상의 HTTP」,
- RFC 2818, 2000년 5월.

[RFC3629]
- Yergeau, F.,
- 「UTF-8, ISO 10646의 변환 형식」,
- STD 63, RFC 3629, 2003년 11월.

[RFC3986]
- Berners-Lee, T., Fielding, R., 및 L. Masinter,
- 「URI(Uniform Resource Identifier): 일반 문법」,
- STD 66, RFC 3986, 2005년 1월.

[RFC4627]
- Crockford, D.,
- 「JavaScript Object Notation(JSON)을 위한 application/json 미디어 타입」,
- RFC 4627, 2006년 7월.

[RFC4949]
- Shirey, R.,
- 「인터넷 보안 용어집, 버전 2」,
- RFC 4949, 2007년 8월.

[RFC5226]
- Narten, T. 및 H. Alvestrand,
- 「RFC에서 IANA 고려 사항(IANA Considerations) 섹션을 작성하기 위한 지침」,
- BCP 26, RFC 5226, 2008년 5월.

[RFC5234]
- Crocker, D. 및 P. Overell,
- 「구문 명세를 위한 확장된 BNF: ABNF」,
- STD 68, RFC 5234, 2008년 1월.

[RFC5246]
- Dierks, T. 및 E. Rescorla,
- 「전송 계층 보안(TLS) 프로토콜 버전 1.2」,
- RFC 5246, 2008년 8월.

[RFC6125]
- Saint-Andre, P. 및 J. Hodges,
- 「TLS 맥락에서 X.509(PKIX) 인증서를 사용한 도메인 기반 애플리케이션 서비스
- 아이덴티티의 표현 및 검증」,
- RFC 6125, 2011년 3월.

[USASCII]
- 미국 국립 표준 협회(ANSI),
- 「부호화 문자 집합 — 7비트 미국 표준 정보 교환 코드」,
- ANSI X3.4, 1986년.

[W3C.REC-html401-19991224]
- Raggett, D., Le Hors, A., 및 I. Jacobs,
- 「HTML 4.01 명세」,
- 월드 와이드 웹 컨소시엄(W3C) 권고안 REC-html401-19991224,
- 1999년 12월,
- http://www.w3.org/TR/1999/REC-html401-19991224￼.

[W3C.REC-xml-20081126]
- Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E., 및 F. Yergeau,
- 「확장 가능 마크업 언어(XML) 1.0 (제5판)」,
- 월드 와이드 웹 컨소시엄(W3C) 권고안 REC-xml-20081126,
- 2008년 11월,
- http://www.w3.org/TR/2008/REC-xml-20081126￼.

### 12.2 정보 제공공 참고 문헌

(Informative References)

[OAuth-HTTP-MAC]
- Hammer-Lahav, E., 편집,
- 「HTTP 인증: MAC 접근 인증」,
- 작업 진행 중(Work in Progress), 2012년 2월.

[OAuth-SAML2]
- Campbell, B. 및 C. Mortimore,
- 「OAuth 2.0을 위한 SAML 2.0 Bearer Assertion 프로파일」,
- 작업 진행 중, 2012년 9월.

[OAuth-THREATMODEL]
- Lodderstedt, T., 편집, McGloin, M., 및 P. Hunt,
- 「OAuth 2.0 위협 모델 및 보안 고려 사항」,
- 작업 진행 중, 2012년 10월.

[OAuth-WRAP]
- Hardt, D., 편집, Tom, A., Eaton, B., 및 Y. Goland,
- 「OAuth 웹 리소스 인가 프로파일」,
- 작업 진행 중, 2010년 1월.

[RFC5849]
- Hammer-Lahav, E.,
- 「OAuth 1.0 프로토콜」,
- RFC 5849, 2010년 4월.

[RFC6750]
- Jones, M. 및 D. Hardt,
- 「OAuth 2.0 인가 프레임워크: Bearer 토큰 사용법」,
- RFC 6750, 2012년 10월.

## 부록 A. 확장된 백커스–나우르 형식(ABNF) 문법
이 절은 [RFC5234]의 표기법을 사용하여, 본 명세에서 정의된 요소들에 대한 확장된 백커스–나우르 형식(ABNF) 문법 설명을 제공한다. 아래의 ABNF는 유니코드 코드 포인트([W3C.REC-xml-20081126])를 기준으로 정의되며, 이러한 문자들은 일반적으로 UTF-8로 인코딩된다. 요소들은 처음 정의된 순서대로 제시된다.

이하의 일부 정의는 [RFC3986]에 정의된 “URI-reference” 정의를 사용한다.

이하의 일부 정의는 다음의 공통 정의들을 사용한다:
```
VSCHAR     = %x20-7E
NQCHAR     = %x21 / %x23-5B / %x5D-7E
NQSCHAR    = %x20-21 / %x23-5B / %x5D-7E
UNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF /
                    %xE000-FFFD / %x10000-10FFFF
```
(UNICODECHARNOCRLF 정의는 [W3C.REC-xml-20081126]의 2.2절에 있는 Char 정의를 기반으로 하되, 캐리지 리턴(Carriage Return) 및 라인피드(Linefeed) 문자를 제외한 것이다.)

### A.1. "client_id" 문법
"client_id" 요소는 2.3.1절에 정의되어 있다:
```
client-id     = *VSCHAR
```

### A.2. "client_secret" 문법
"client_secret" 요소는 2.3.1절에 정의되어 있다:
```
client-secret = *VSCHAR
```

### A.3. "response_type" 문법
"response_type" 요소는 3.1.1절 및 8.4절에 정의되어 있다:
```
response-type = response-name *( SP response-name )
response-name = 1*response-char
response-char = "_" / DIGIT / ALPHA
```

### A.4. "scope" 문법
"scope" 요소는 3.3절에 정의되어 있다:
```
scope       = scope-token *( SP scope-token )
scope-token = 1*NQCHAR
```
### A.5. "state" 문법
"state" 요소는 4.1.1절, 4.1.2절, 4.1.2.1절, 4.2.1절, 4.2.2절, 4.2.2.1절에 정의되어 있다:
```
state      = 1*VSCHAR
```

### A.6. "redirect_uri" 문법
"redirect_uri" 요소는 4.1.1절, 4.1.3절, 4.2.1절에 정의되어 있다:
```
redirect-uri      = URI-reference
```
### A.7. "error" 문법
"error" 요소는 4.1.2.1절, 4.2.2.1절, 5.2절, 7.2절, 8.5절에 정의되어 있다:
```
error             = 1*NQSCHAR
```
### A.8. "error_description" 문법
"error_description" 요소는 4.1.2.1절, 4.2.2.1절, 5.2절, 7.2절에 정의되어 있다:
```
error-description = 1*NQSCHAR
```

### A.9. "error_uri" 문법
"error_uri" 요소는 4.1.2.1절, 4.2.2.1절, 5.2절, 7.2절에 정의되어 있다:
```
error-uri         = URI-reference
```
### A.10. "grant_type" 문법
"grant_type" 요소는 4.1.3절, 4.3.2절, 4.4.2절, 4.5절, 6절에 정의되어 있다:
```
grant-type = grant-name / URI-reference
grant-name = 1*name-char
name-char  = "-" / "." / "_" / DIGIT / ALPHA
```

### A.11. "code" 문법
"code" 요소는 4.1.3절에 정의되어 있다:
```
code       = 1*VSCHAR
```

### A.12. "access_token" 문법
"access_token" 요소는 4.2.2절 및 5.1절에 정의되어 있다:
```
access-token = 1*VSCHAR
```

### A.13. "token_type" 문법
"token_type" 요소는 4.2.2절, 5.1절, 8.1절에 정의되어 있다:
```
token-type = type-name / URI-reference
type-name  = 1*name-char
name-char  = "-" / "." / "_" / DIGIT / ALPHA
```

### A.14. "expires_in" 문법
"expires_in" 요소는 4.2.2절 및 5.1절에 정의되어 있다:
```
expires-in = 1*DIGIT
```

### A.15. "username" 문법
"username" 요소는 4.3.2절에 정의되어 있다:
```
username = *UNICODECHARNOCRLF
```
### A.16. "password" 문법
"password" 요소는 4.3.2절에 정의되어 있다:
```
password = *UNICODECHARNOCRLF
```

### A.17. "refresh_token" 문법
"refresh_token" 요소는 5.1절 및 6절에 정의되어 있다:
```
refresh-token = 1*VSCHAR
```
### A.18. 엔드포인트 매개변수 문법
새로운 엔드포인트 매개변수에 대한 문법은 8.2절에 정의되어 있다:
```
param-name = 1*name-char
name-char  = "-" / "." / "_" / DIGIT / ALPHA
```

## 부록 B. application/x-www-form-urlencoded 미디어 타입의 사용
본 명세가 발행될 당시, "application/x-www-form-urlencoded" 미디어 타입은 [W3C.REC-html401-19991224]의 17.13.4절에 정의되어 있었으나, IANA MIME Media Types 레지스트리
(http://www.iana.org/assignments/media-types￼)에는 등록되어 있지 않았다. 또한, 해당 정의는 미국 ASCII(US-ASCII)가 아닌 문자를 고려하지 않았기 때문에 불완전하다.

이 미디어 타입을 사용하여 페이로드(payload)를 생성할 때 이러한 한계를 해결하기 위해, 이름(name)과 값(value)은 먼저 UTF-8 문자 인코딩 방식([RFC3629])을 사용하여 인코딩되어야 하며(MUST), 그 결과로 생성된 옥텟(octet) 시퀀스는 [W3C.REC-html401-19991224]에 정의된 이스케이프 규칙을 사용하여 다시 인코딩되어야 한다.

이 미디어 타입을 사용한 페이로드로부터 데이터를 파싱할 때에는, 이름/값 인코딩을 역으로 복원한 결과를 옥텟 시퀀스로 취급해야 하며, 이를 UTF-8 문자 인코딩 방식을 사용하여 디코딩해야 한다.

예를 들어, 다음의 여섯 개 유니코드 코드 포인트로 구성된 값:
1. U+0020 (SPACE)
2. U+0025 (PERCENT SIGN)
3. U+0026 (AMPERSAND)
4. U+002B (PLUS SIGN)
5. U+00A3 (POUND SIGN)
6. U+20AC (EURO SIGN)

은 (16진수 표기법을 사용하여) 다음과 같은 옥텟 시퀀스로 인코딩된다:
```
20 25 26 2B C2 A3 E2 82 AC
```
그리고 이는 페이로드 내에서 다음과 같이 표현된다:
```
+%25%26%2B%C2%A3%E2%82%AC
```

## 부록 C. 감사의 말
초기 OAuth 2.0 프로토콜 명세는 David Recordon이 편집하였으며, 이는 두 개의 이전 출판물인 OAuth 1.0 커뮤니티 명세([RFC5849])와 OAuth WRAP(OAuth Web Resource Authorization Profiles) [OAuth-WRAP]를 기반으로 하였다. 이후 Eran Hammer가 이 RFC로 발전하는 과정에서 여러 중간 초안들을 편집하였다.

보안 고려 사항(Security Considerations) 절은 Torsten Lodderstedt, Mark McGloin, Phil Hunt, Anthony Nadalin, John Bradley에 의해 작성되었다. "application/x-www-form-urlencoded" 미디어 타입 사용에 대한 절은 Julian Reschke가 작성하였다. ABNF 절은 Michael B. Jones가 작성하였다.

OAuth 1.0 커뮤니티 명세는 Eran Hammer가 편집하였고, Mark Atwood, Dirk Balfanz, Darren Bounds, Richard M. Conlan, Blaine Cook, Leah Culver, Breno de Medeiros, Brian Eaton, Kellan Elliott-McCrea, Larry Halff, Eran Hammer, Ben Laurie, Chris Messina, John Panzer, Sam Quigley, David Recordon, Eran Sandler, Jonathan Sergent, Todd Sieling, Brian Slesinsky, Andy Smith에 의해 저술되었다.

OAuth WRAP 명세는 Dick Hardt가 편집하였으며, Brian Eaton, Yaron Y. Goland, Dick Hardt, Allen Tom이 저술하였다.

본 명세는 OAuth 워킹 그룹의 작업 결과로, 수십 명의 적극적이고 헌신적인 참여자들이 포함되어 있다. 특히 다음 인물들은 최종 명세를 형성하고 다듬는 데 아이디어, 피드백, 문구를 제공하였다:

Michael Adams, Amanda Anganes, Andrew Arnott, Dirk Balfanz, Aiden Bell, John Bradley, Marcos Caceres, Brian Campbell, Scott Cantor, Blaine Cook, Roger Crew, Leah Culver, Bill de hOra, Andre DeMarre, Brian Eaton, Wesley Eddy, Wolter Eldering, Brian Ellin, Igor Faynberg, George Fletcher, Tim Freeman, Luca Frosini, Evan Gilbert, Yaron Y. Goland, Brent Goldman, Kristoffer Gronowski, Eran Hammer, Dick Hardt, Justin Hart, Craig Heath, Phil Hunt, Michael B. Jones, Terry Jones, John Kemp, Mark Kent, Raffi Krikorian, Chasen Le Hara, Rasmus Lerdorf, Torsten Lodderstedt, Hui-Lan Lu, Casey Lucas, Paul Madsen, Alastair Mair, Eve Maler, James Manger, Mark McGloin, Laurence Miao, William Mills, Chuck Mortimore, Anthony Nadalin, Julian Reschke, Justin Richer, Peter Saint-Andre, Nat Sakimura, Rob Sayre, Marius Scurtescu, Naitik Shah, Luke Shepard, Vlad Skvortsov, Justin Smith, Haibin Song, Niv Steingarten, Christian Stuebner, Jeremy Suriel, Paul Tarjan, Christopher Thomas, Henry S. Thompson, Allen Tom, Franklin Tse, Nick Walker, Shane Weeden, Skylar Woodward.

본 문서는 Blaine Cook, Peter Saint-Andre, Hannes Tschofenig, Barry Leiba, Derek Atkins의 의장 하에 작성되었다. 영역 책임자(area directors)는 Lisa Dusseault, Peter Saint-Andre, Stephen Farrell였다.

저자 주소

(Author’s Address)

Dick Hardt (편집자)
Microsoft

이메일: dick.hardt@gmail.com
URI: http://dickhardt.org/